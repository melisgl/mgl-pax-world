<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<head>
<title>MAT Manual</title>
<link type='text/css' href='style.css' rel='stylesheet'/>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<script src="jquery.min.js"></script>
<script src="toc.min.js"></script>
<script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {
         inlineMath: [['$','$']],
         processEscapes: true
       }
     });
   </script>
   <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
   </script>
   </head>
<body>
<div id="content-container">
<div id="toc">
<div id="toc-header"><ul><li><a href="index.html">PAX World</a></li></ul></div>
<div id="page-toc">
</div>
<div id="toc-footer"><ul><li><a href="https://github.com/melisgl/mgl-pax">[generated by MGL-PAX]</a></li></ul></div>
</div>
<div id="content">
<p><a id='x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28-22mgl-mat-22-20ASDF-2FSYSTEM-3ASYSTEM-29" title="(\&quot;mgl-mat\&quot; ASDF/SYSTEM:SYSTEM)">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L14">&#955;</a></span></span></p>

<h1><a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29">MAT Manual</a></h1>

<h2>Table of Contents</h2>

<ul>
<li><a href="#x-28-22mgl-mat-22-20ASDF-2FSYSTEM-3ASYSTEM-29" title="(\&quot;mgl-mat\&quot; ASDF/SYSTEM:SYSTEM)">1 MGL-MAT ASDF System Details</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-LINKS-20MGL-PAX-3ASECTION-29" title="Links">2 Links</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29" title="Introduction">3 Introduction</a>

<ul>
<li><a href="#x-28MGL-MAT-3A-40MAT-WHAT-IS-IT-20MGL-PAX-3ASECTION-29" title="What's MGL-MAT?">3.1 What's MGL-MAT?</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-WHAT-KIND-OF-MATRICES-20MGL-PAX-3ASECTION-29" title="What kind of matrices are supported?">3.2 What kind of matrices are supported?</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-INSTALLATION-20MGL-PAX-3ASECTION-29" title="Where to Get it?">3.3 Where to Get it?</a></li>
</ul></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-TUTORIAL-20MGL-PAX-3ASECTION-29" title="Tutorial">4 Tutorial</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-BASICS-20MGL-PAX-3ASECTION-29" title="Basics">5 Basics</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-CTYPES-20MGL-PAX-3ASECTION-29" title="Element types">6 Element types</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-PRINTING-20MGL-PAX-3ASECTION-29" title="Printing">7 Printing</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29" title="Shaping">8 Shaping</a>

<ul>
<li><a href="#x-28MGL-MAT-3A-40MAT-SHAPING-COMPARISON-TO-LISP-20MGL-PAX-3ASECTION-29" title="Comparison to Lisp Arrays">8.1 Comparison to Lisp Arrays</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-SHAPING-FUNCTIONAL-20MGL-PAX-3ASECTION-29" title="Functional Shaping">8.2 Functional Shaping</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-SHAPING-DESTRUCTIVE-20MGL-PAX-3ASECTION-29" title="Destructive Shaping">8.3 Destructive Shaping</a></li>
</ul></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-ASSEMBLING-20MGL-PAX-3ASECTION-29" title="Assembling">9 Assembling</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-CACHING-20MGL-PAX-3ASECTION-29" title="Caching">10 Caching</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-BLAS-20MGL-PAX-3ASECTION-29" title="BLAS Operations">11 BLAS Operations</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29" title="Destructive API">12 Destructive API</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-NON-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29" title="Non-destructive API">13 Non-destructive API</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-MAPPINGS-20MGL-PAX-3ASECTION-29" title="Mappings">14 Mappings</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-RANDOM-20MGL-PAX-3ASECTION-29" title="Random numbers">15 Random numbers</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-IO-20MGL-PAX-3ASECTION-29" title="I/O">16 I/O</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-DEBUGGING-20MGL-PAX-3ASECTION-29" title="Debugging">17 Debugging</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-FACET-API-20MGL-PAX-3ASECTION-29" title="Facet API">18 Facet API</a>

<ul>
<li><a href="#x-28MGL-MAT-3A-40MAT-FACETS-20MGL-PAX-3ASECTION-29" title="Facets">18.1 Facets</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-FOREIGN-20MGL-PAX-3ASECTION-29" title="Foreign arrays">18.2 Foreign arrays</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-CUDA-20MGL-PAX-3ASECTION-29" title="CUDA">18.3 CUDA</a>

<ul>
<li><a href="#x-28MGL-MAT-3A-40MAT-CUDA-MEMORY-MANAGEMENT-20MGL-PAX-3ASECTION-29" title="CUDA Memory Management">18.3.1 CUDA Memory Management</a></li>
</ul></li>
</ul></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-EXTENSIONS-20MGL-PAX-3ASECTION-29" title="Writing Extensions">19 Writing Extensions</a>

<ul>
<li><a href="#x-28MGL-MAT-3A-40MAT-LISP-EXTENSIONS-20MGL-PAX-3ASECTION-29" title="Lisp Extensions">19.1 Lisp Extensions</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-CUDA-EXTENSIONS-20MGL-PAX-3ASECTION-29" title="CUDA Extensions">19.2 CUDA Extensions</a>

<ul>
<li><a href="#x-28MGL-MAT-3A-40MAT-CUBLAS-20MGL-PAX-3ASECTION-29" title="CUBLAS">19.2.1 CUBLAS</a></li>
<li><a href="#x-28MGL-MAT-3A-40MAT-CURAND-20MGL-PAX-3ASECTION-29" title="CURAND">19.2.2 CURAND</a></li>
</ul></li>
</ul></li>
</ul>

<h6>[in package MGL-MAT]</h6>

<p><a id='x-28-22mgl-mat-22-20ASDF-2FSYSTEM-3ASYSTEM-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-LINKS-20MGL-PAX-3ASECTION-29" title="Links">&#8594;</a> <a href="#x-28-22mgl-mat-22-20ASDF-2FSYSTEM-3ASYSTEM-29" title="(\&quot;mgl-mat\&quot; ASDF/SYSTEM:SYSTEM)">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/mgl-mat.asd#L1">&#955;</a></span></span></p>

<h2><a href="#x-28-22mgl-mat-22-20ASDF-2FSYSTEM-3ASYSTEM-29">1 MGL-MAT ASDF System Details</a></h2>

<ul>
<li>Version: 0.1.0</li>
<li>Description: <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> is library for working with multi-dimensional
  arrays which supports efficient interfacing to foreign and CUDA
  code. BLAS and CUBLAS bindings are available.</li>
<li>Licence: MIT, see COPYING.</li>
<li>Author: GÃ¡bor Melis <a href="m&#x61;&#105;l&#x74;&#111;:&#x6D;&#101;g&#x61;&#64;r&#x65;&#116;e&#x73;&#46;h&#x75;">m&#x61;&#105;l&#x74;&#111;:&#x6D;&#101;g&#x61;&#64;r&#x65;&#116;e&#x73;&#46;h&#x75;</a></li>
<li>Mailto: <a href="mailto:mega@retes.hu" >mega@retes.hu</a></li>
<li>Homepage: <a href="http://melisgl.github.io/mgl-mat" >http://melisgl.github.io/mgl-mat</a></li>
<li>Bug tracker: <a href="https://github.com/melisgl/mgl-mat/issues" >https://github.com/melisgl/mgl-mat/issues</a></li>
<li>Source control: <a href="https://github.com/melisgl/mgl-mat.git" >GIT</a></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-LINKS-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28-22mgl-mat-22-20ASDF-2FSYSTEM-3ASYSTEM-29" title="(\&quot;mgl-mat\&quot; ASDF/SYSTEM:SYSTEM)">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29" title="Introduction">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-LINKS-20MGL-PAX-3ASECTION-29" title="Links">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L35">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-LINKS-20MGL-PAX-3ASECTION-29">2 Links</a></h2>

<p>Here is the <a href="https://github.com/melisgl/mgl-mat" >official
repository</a> and the <a href="http://melisgl.github.io/mgl-mat/mat-manual.html" >HTML
documentation</a>
for the latest version.</p>

<p><a id='x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-LINKS-20MGL-PAX-3ASECTION-29" title="Links">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-WHAT-IS-IT-20MGL-PAX-3ASECTION-29" title="What's MGL-MAT?">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29" title="Introduction">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L41">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29">3 Introduction</a></h2>

<p><a id='x-28MGL-MAT-3A-40MAT-WHAT-IS-IT-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29" title="Introduction">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29" title="Introduction">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-WHAT-KIND-OF-MATRICES-20MGL-PAX-3ASECTION-29" title="What kind of matrices are supported?">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-WHAT-IS-IT-20MGL-PAX-3ASECTION-29" title="What's MGL-MAT?">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L46">&#955;</a></span></span></p>

<h3><a href="#x-28MGL-MAT-3A-40MAT-WHAT-IS-IT-20MGL-PAX-3ASECTION-29">3.1 What's MGL-MAT?</a></h3>

<p>MGL-MAT is library for working with multi-dimensional arrays
which supports efficient interfacing to foreign and CUDA code with
automatic translations between cuda, foreign and lisp storage. BLAS
and CUBLAS bindings are available.</p>

<p><a id='x-28MGL-MAT-3A-40MAT-WHAT-KIND-OF-MATRICES-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-WHAT-IS-IT-20MGL-PAX-3ASECTION-29" title="What's MGL-MAT?">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29" title="Introduction">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-INSTALLATION-20MGL-PAX-3ASECTION-29" title="Where to Get it?">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-WHAT-KIND-OF-MATRICES-20MGL-PAX-3ASECTION-29" title="What kind of matrices are supported?">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L52">&#955;</a></span></span></p>

<h3><a href="#x-28MGL-MAT-3A-40MAT-WHAT-KIND-OF-MATRICES-20MGL-PAX-3ASECTION-29">3.2 What kind of matrices are supported?</a></h3>

<p>Currently only row-major single and double float matrices are
supported, but it would be easy to add single and double precision
complex types too. Other numeric types, such as byte and native
integer, can be added too, but they are not supported by CUBLAS.
There are no restrictions on the number of dimensions, and reshaping
is possible. All functions operate on the visible portion of the
matrix (which is subject to displacement and shaping), invisible
elements are not affected.</p>

<p><a id='x-28MGL-MAT-3A-40MAT-INSTALLATION-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-WHAT-KIND-OF-MATRICES-20MGL-PAX-3ASECTION-29" title="What kind of matrices are supported?">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-INTRODUCTION-20MGL-PAX-3ASECTION-29" title="Introduction">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-TUTORIAL-20MGL-PAX-3ASECTION-29" title="Tutorial">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-INSTALLATION-20MGL-PAX-3ASECTION-29" title="Where to Get it?">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L63">&#955;</a></span></span></p>

<h3><a href="#x-28MGL-MAT-3A-40MAT-INSTALLATION-20MGL-PAX-3ASECTION-29">3.3 Where to Get it?</a></h3>

<p>All dependencies are in quicklisp except for
<a href="https://github.com/takagi/cl-cuda" >CL-CUDA</a> that needs to be
fetched from github. Just clone CL-CUDA and MGL-MAT into
<code>quicklisp/local-projects/</code> and you are set. MGL-MAT itself lives
<a href="https://github.com/melisgl/mgl-mat" >at github</a>, too.</p>

<p>Prettier-than-markdown HTML documentation cross-linked with other
libraries is
<a href="http://melisgl.github.io/mgl-pax-world/mat-manual.html" >available</a>
as part of <a href="http://melisgl.github.io/mgl-pax-world/" >PAX World</a>.</p>

<p><a id='x-28MGL-MAT-3A-40MAT-TUTORIAL-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-INSTALLATION-20MGL-PAX-3ASECTION-29" title="Where to Get it?">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-BASICS-20MGL-PAX-3ASECTION-29" title="Basics">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-TUTORIAL-20MGL-PAX-3ASECTION-29" title="Tutorial">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L76">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-TUTORIAL-20MGL-PAX-3ASECTION-29">4 Tutorial</a></h2>

<p>We are going to see how to create matrices, access their contents.</p>

<p>Creating matrices is just like creating lisp arrays:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">make-mat '6</span>)</span>
==&gt; #&lt;MAT 6 A #<span class="paren1">(<span class="code">0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0</span>)</span>&gt;

<span class="paren1">(<span class="code">make-mat '<span class="paren2">(<span class="code">2 3</span>)</span> <span class="keyword">:ctype</span> <span class="keyword">:float</span> <span class="keyword">:initial-contents</span> '<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">1 2 3</span>)</span> <span class="paren3">(<span class="code">4 5 6</span>)</span></span>)</span></span>)</span>
==&gt; #&lt;MAT 2x3 AB #2A<span class="paren1">(<span class="code"><span class="paren2">(<span class="code">1.0 2.0 3.0</span>)</span> <span class="paren2">(<span class="code">4.0 5.0 6.0</span>)</span></span>)</span>&gt;

<span class="paren1">(<span class="code">make-mat '<span class="paren2">(<span class="code">2 3 4</span>)</span> <span class="keyword">:initial-element</span> 1</span>)</span>
==&gt; #&lt;MAT 2x3x4 A #3A<span class="paren1">(<span class="code"><span class="paren2">(<span class="code"><span class="paren3">(<span class="code">1.0d0 1.0d0 1.0d0 1.0d0</span>)</span>
--&gt;                    <span class="paren3">(<span class="code">1.0d0 1.0d0 1.0d0 1.0d0</span>)</span>
--&gt;                    <span class="paren3">(<span class="code">1.0d0 1.0d0 1.0d0 1.0d0</span>)</span></span>)</span>
--&gt;                   <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">1.0d0 1.0d0 1.0d0 1.0d0</span>)</span>
--&gt;                    <span class="paren3">(<span class="code">1.0d0 1.0d0 1.0d0 1.0d0</span>)</span>
--&gt;                    <span class="paren3">(<span class="code">1.0d0 1.0d0 1.0d0 1.0d0</span>)</span></span>)</span></span>)</span>&gt;</span></code></pre>

<p>The most prominent difference from lisp arrays is that <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a>s are
always numeric and their element type (called <a href="#x-28MGL-MAT-3ACTYPE-20TYPE-29" title="(MGL-MAT:CTYPE TYPE)"><code>CTYPE</code></a> here) defaults
to <code>:DOUBLE</code>.</p>

<p>Individual elements can be accessed or set with <a href="#x-28MGL-MAT-3AMREF-20FUNCTION-29" title="(MGL-MAT:MREF FUNCTION)"><code>MREF</code></a>:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">m <span class="paren4">(<span class="code">make-mat '<span class="paren5">(<span class="code">2 3</span>)</span></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren3">(<span class="code">mref m 0 0</span>)</span> 1</span>)</span>
  <span class="paren2">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren3">(<span class="code">mref m 0 1</span>)</span> <span class="paren3">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> 2 <span class="paren4">(<span class="code">mref m 0 0</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_incf_.htm" class="symbol">incf</a> <span class="paren3">(<span class="code">mref m 0 2</span>)</span> 4</span>)</span>
  m</span>)</span>
==&gt; #&lt;MAT 2x3 AB #2A<span class="paren1">(<span class="code"><span class="paren2">(<span class="code">1.0d0 2.0d0 4.0d0</span>)</span> <span class="paren2">(<span class="code">0.0d0 0.0d0 0.0d0</span>)</span></span>)</span>&gt;</span></code></pre>

<p>Compared to <code>AREF</code> <code>MREF</code> is a very expensive operation and it's best
used sparingly. Instead, typical code relies much more on matrix
level operations:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm" class="symbol">princ</a> <span class="paren2">(<span class="code">scal! 2 <span class="paren3">(<span class="code">fill! 3 <span class="paren4">(<span class="code">make-mat 4</span>)</span></span>)</span></span>)</span></span>)</span>
.. #&lt;MAT 4 BF #<span class="paren1">(<span class="code">6.0d0 6.0d0 6.0d0 6.0d0</span>)</span>&gt;
==&gt; #&lt;MAT 4 ABF #<span class="paren1">(<span class="code">6.0d0 6.0d0 6.0d0 6.0d0</span>)</span>&gt;</span></code></pre>

<p>The content of a matrix can be accessed in various representations
called <em>facets</em>. MGL-MAT takes care of synchronizing these facets
by copying data around lazily, but doing its best to share storage
for facets that allow it.</p>

<p>Notice the <code>ABF</code> in the printed results. It illustrates that behind
the scenes <a href="#x-28MGL-MAT-3AFILL-21-20FUNCTION-29" title="(MGL-MAT:FILL! FUNCTION)"><code>FILL!</code></a> worked on the <a href="#x-28MGL-MAT-3ABACKING-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:BACKING-ARRAY MGL-CUBE:FACET-NAME)"><code>BACKING-ARRAY</code></a>
facet (hence the <code>B</code>) that's basically a 1d lisp array. <a href="#x-28MGL-MAT-3ASCAL-21-20FUNCTION-29" title="(MGL-MAT:SCAL! FUNCTION)"><code>SCAL!</code></a> on the
other hand made a foreign call to the BLAS <code>dscal</code> function for
which it needed the <a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:FOREIGN-ARRAY MGL-CUBE:FACET-NAME)"><code>FOREIGN-ARRAY</code></a> facet (<code>F</code>).
Finally, the <code>A</code> stands for the <a href="#x-28ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(ARRAY MGL-CUBE:FACET-NAME)"><code>ARRAY</code></a> facet that was
created when the array was printed. All facets are up-to-date (else
some of the characters would be lowercase). This is possible because
these three facets actually share storage which is never the case
for the <a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a> facet. Now if we have a
CUDA-capable GPU, CUDA can be enabled with <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a>:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">with-cuda*</span></i> <span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm" class="symbol">princ</a> <span class="paren3">(<span class="code">scal! 2 <span class="paren4">(<span class="code">fill! 3 <span class="paren5">(<span class="code">make-mat 4</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
.. #&lt;MAT 4 C #<span class="paren1">(<span class="code">6.0d0 6.0d0 6.0d0 6.0d0</span>)</span>&gt;
==&gt; #&lt;MAT 4 A #<span class="paren1">(<span class="code">6.0d0 6.0d0 6.0d0 6.0d0</span>)</span>&gt;</span></code></pre>

<p>Note the lonely <code>C</code> showing that only the <a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a>
facet was used for both <code>FILL!</code> and <code>SCAL!</code>. When <code>WITH-CUDA*</code> exits and
destroys the CUDA context, it destroys all CUDA facets, moving their
data to the <a href="#x-28ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(ARRAY MGL-CUBE:FACET-NAME)"><code>ARRAY</code></a> facet, so the returned <code>MAT</code> only has
that facet.</p>

<p>When there is no high-level operation that does what we want, we may
need to add new operations. This is usually best accomplished by
accessing one of the facets directly, as in the following example:</p>

<p><a id='x-28MGL-MAT-3A-3ALOG-DET-EXAMPLE-20-28MGL-PAX-3AINCLUDE-20-28-3ASTART-20-28MGL-MAT-3ALOGDET-20FUNCTION-29-20-3AEND-20-28MGL-MAT-3A-3AEND-OF-LOGDET-EXAMPLE-20VARIABLE-29-29-20-3AHEADER-NL-20-22-60-60-60commonlisp-22-20-3AFOOTER-NL-20-22-60-60-60-22-29-29'></a></p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> logdet <span class="paren2">(<span class="code">mat</span>)</span>
  <span class="string">"Logarithm of the determinant of MAT. Return -1, 1 or 0 (or
  equivalent) to correct for the sign, as the second value."</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">with-facets</span></i> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/t_array.htm" class="symbol">array</a> <span class="paren5">(<span class="code">mat '<a href="http://www.lispworks.com/reference/HyperSpec/Body/t_array.htm" class="symbol">array</a> <span class="keyword">:direction</span> <span class="keyword">:input</span></span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">lla:logdet <a href="http://www.lispworks.com/reference/HyperSpec/Body/t_array.htm" class="symbol">array</a></span>)</span></span>)</span></span>)</span>
</span></code></pre>

<p>Notice that <a href="#x-28MGL-MAT-3ALOGDET-20FUNCTION-29" title="(MGL-MAT:LOGDET FUNCTION)"><code>LOGDET</code></a> doesn't know about CUDA at all. <a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACETS-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACETS MGL-PAX:MACRO)"><code>WITH-FACETS</code></a>
gives it the content of the matrix as a normal multidimensional lisp
array, copying the data from the GPU or elsewhere if necessary. This
allows new representations (<a href="cube-manual.html#x-28MGL-CUBE-3AFACET-20CLASS-29" title="(MGL-CUBE:FACET CLASS)"><code>FACET</code></a>s) to be added easily and it also
avoids copying if the facet is already up-to-date. Of course, adding
CUDA support to <code>LOGDET</code> could make it more efficient.</p>

<p>Adding support for matrices that, for instance, live on a remote
machine is thus possible with a new facet type and existing code
would continue to work (albeit possibly slowly). Then one could
optimize the bottleneck operations by sending commands over the
network instead of copying data.</p>

<p>It is a bad idea to conflate resource management policy and
algorithms. MGL-MAT does its best to keep them separate.</p>

<p><a id='x-28MGL-MAT-3A-40MAT-BASICS-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-TUTORIAL-20MGL-PAX-3ASECTION-29" title="Tutorial">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-CTYPES-20MGL-PAX-3ASECTION-29" title="Element types">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-BASICS-20MGL-PAX-3ASECTION-29" title="Basics">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L176">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-BASICS-20MGL-PAX-3ASECTION-29">5 Basics</a></h2>

<p><a id='x-28MGL-MAT-3AMAT-20CLASS-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L196">[class]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAT-20CLASS-29" >MAT</a></span></span> <span class="locative-args"><a href="cube-manual.html#x-28MGL-CUBE-3ACUBE-20CLASS-29" title="(MGL-CUBE:CUBE CLASS)">CUBE</a></span></span></p>

<p>A <code>MAT</code> is a data <a href="cube-manual.html#x-28MGL-CUBE-3ACUBE-20CLASS-29" title="(MGL-CUBE:CUBE CLASS)"><code>CUBE</code></a> that is much like a lisp
array, it supports <code>DISPLACEMENT</code>, arbitrary <code>DIMENSIONS</code> and
<code>INITIAL-ELEMENT</code> with the usual semantics. However, a <code>MAT</code> supports
different representations of the same data. See <a href="#x-28MGL-MAT-3A-40MAT-TUTORIAL-20MGL-PAX-3ASECTION-29" title="Tutorial">Tutorial</a> for
an introduction.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AMAT-CTYPE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L248">[reader]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAT-CTYPE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" >MAT-CTYPE</a></span></span> <span class="locative-args">MAT</span> <span class="locative-args">(:CTYPE = <a href="#x-28MGL-MAT-3A-2ADEFAULT-MAT-CTYPE-2A-20VARIABLE-29" title="(MGL-MAT:*DEFAULT-MAT-CTYPE* VARIABLE)"><code>*DEFAULT-MAT-CTYPE*</code></a>)</span></span></p>

<p>One of <a href="#x-28MGL-MAT-3A-2ASUPPORTED-CTYPES-2A-20VARIABLE-29" title="(MGL-MAT:*SUPPORTED-CTYPES* VARIABLE)"><code>*SUPPORTED-CTYPES*</code></a>. The matrix can hold
only values of this type.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AMAT-DISPLACEMENT-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L197">[reader]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAT-DISPLACEMENT-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" >MAT-DISPLACEMENT</a></span></span> <span class="locative-args">MAT</span> <span class="locative-args">(:DISPLACEMENT = 0)</span></span></p>

<p>A value in the <code>[0,MAX-SIZE]</code> interval. This is
like the DISPLACED-INDEX-OFFSET of a lisp array, but displacement
is relative to the start of the underlying storage vector.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AMAT-DIMENSIONS-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L202">[reader]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAT-DIMENSIONS-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" >MAT-DIMENSIONS</a></span></span> <span class="locative-args">MAT</span> <span class="locative-args">(:DIMENSIONS)</span></span></p>

<p>Like <code>ARRAY-DIMENSIONS</code>. It holds a list of
dimensions, but it is allowed to pass in scalars too.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AMAT-DIMENSION-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L299">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAT-DIMENSION-20FUNCTION-29" >MAT-DIMENSION</a></span></span> <span class="locative-args">MAT AXIS-NUMBER</span></span></p>

<p>Return the dimension along <code>AXIS-NUMBER</code>. Similar to
<code>ARRAY-DIMENSION</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AMAT-INITIAL-ELEMENT-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L251">[reader]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAT-INITIAL-ELEMENT-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" >MAT-INITIAL-ELEMENT</a></span></span> <span class="locative-args">MAT</span> <span class="locative-args">(:INITIAL-ELEMENT = 0)</span></span></p>

<p>If non-nil, then when a facet is created, it is
filled with <code>INITIAL-ELEMENT</code> coerced to the appropriate numeric
type. If <code>NIL</code>, then no initialization is performed.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L206">[reader]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" >MAT-SIZE</a></span></span> <span class="locative-args">MAT</span></span></p>

<p>The number of elements in the visible portion of
the array. This is always the product of the elements
<a href="#x-28MGL-MAT-3AMAT-DIMENSIONS-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-DIMENSIONS (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-DIMENSIONS</code></a> and is similar to <code>ARRAY-TOTAL-SIZE</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AMAT-MAX-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L254">[reader]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAT-MAX-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" >MAT-MAX-SIZE</a></span></span> <span class="locative-args">MAT</span> <span class="locative-args">(:MAX-SIZE)</span></span></p>

<p>The number of elements for which storage may be
allocated. This is <code>DISPLACEMENT</code> + <a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> + <code>SLACK</code> where <code>SLACK</code>
is the number of trailing invisible elements.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AMAKE-MAT-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L304">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAKE-MAT-20FUNCTION-29" >MAKE-MAT</a></span></span> <span class="locative-args">DIMENSIONS &amp;REST ARGS &amp;KEY (CTYPE <a href="#x-28MGL-MAT-3A-2ADEFAULT-MAT-CTYPE-2A-20VARIABLE-29" title="(MGL-MAT:*DEFAULT-MAT-CTYPE* VARIABLE)"><code>*DEFAULT-MAT-CTYPE*</code></a>) (DISPLACEMENT 0) MAX-SIZE INITIAL-ELEMENT INITIAL-CONTENTS (SYNCHRONIZATION <a href="cube-manual.html#x-28MGL-CUBE-3A-2ADEFAULT-SYNCHRONIZATION-2A-20VARIABLE-29" title="(MGL-CUBE:*DEFAULT-SYNCHRONIZATION* VARIABLE)"><code>*DEFAULT-SYNCHRONIZATION*</code></a>) DISPLACED-TO (CUDA-ENABLED <a href="#x-28MGL-MAT-3A-2ADEFAULT-MAT-CUDA-ENABLED-2A-20VARIABLE-29" title="(MGL-MAT:*DEFAULT-MAT-CUDA-ENABLED* VARIABLE)"><code>*DEFAULT-MAT-CUDA-ENABLED*</code></a>)</span></span></p>

<p>Return a new <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> object. If <code>INITIAL-CONTENTS</code> is given then the
matrix contents are initialized with <a href="#x-28MGL-MAT-3AREPLACE-21-20FUNCTION-29" title="(MGL-MAT:REPLACE! FUNCTION)"><code>REPLACE!</code></a>. See class <code>MAT</code> for the
description of the rest of the parameters. This is exactly
what (<code>MAKE-INSTANCE</code> '<code>MAT</code> ...) does except <code>DIMENSIONS</code> is not a
keyword argument so that <code>MAKE-MAT</code> looks more like <code>MAKE-ARRAY</code>. The
semantics of <code>SYNCHRONIZATION</code> are desribed in the
<a href="cube-manual.html#x-28MGL-CUBE-3A-40CUBE-SYNCHRONIZATION-20MGL-PAX-3ASECTION-29" title="Synchronization">Synchronization</a> section.</p>

<p>If specified, <code>DISPLACED-TO</code> must be a <code>MAT</code> object large enough (in the
sense of its <a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a>), to hold <code>DISPLACEMENT</code> plus <code>(REDUCE #'*
DIMENSIONS)</code> elements. Just like with <code>MAKE-ARRAY</code>, <code>INITIAL-ELEMENT</code>
and <code>INITIAL-CONTENTS</code> must not be supplied together with
<code>DISPLACED-TO</code>. See <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29" title="Shaping">Shaping</a> for more.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AARRAY-TO-MAT-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L329">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AARRAY-TO-MAT-20FUNCTION-29" >ARRAY-TO-MAT</a></span></span> <span class="locative-args">ARRAY &amp;KEY CTYPE (SYNCHRONIZATION <a href="cube-manual.html#x-28MGL-CUBE-3A-2ADEFAULT-SYNCHRONIZATION-2A-20VARIABLE-29" title="(MGL-CUBE:*DEFAULT-SYNCHRONIZATION* VARIABLE)"><code>*DEFAULT-SYNCHRONIZATION*</code></a>)</span></span></p>

<p>Create a <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> that's equivalent to <code>ARRAY</code>. Displacement of the
created array will be 0 and the size will be equal to
<code>ARRAY-TOTAL-SIZE</code>. If <code>CTYPE</code> is non-nil, then it will be the ctype of
the new matrix. Else <code>ARRAY</code>'s type is converted to a ctype. If there
is no corresponding ctype, then <a href="#x-28MGL-MAT-3A-2ADEFAULT-MAT-CTYPE-2A-20VARIABLE-29" title="(MGL-MAT:*DEFAULT-MAT-CTYPE* VARIABLE)"><code>*DEFAULT-MAT-CTYPE*</code></a> is used.
Elements of <code>ARRAY</code> are coerced to <code>CTYPE</code>.</p>

<p>Also see <a href="cube-manual.html#x-28MGL-CUBE-3A-40CUBE-SYNCHRONIZATION-20MGL-PAX-3ASECTION-29" title="Synchronization">Synchronization</a>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AMAT-TO-ARRAY-20FUNCTION-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L355">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAT-TO-ARRAY-20FUNCTION-29" >MAT-TO-ARRAY</a></span></span> <span class="locative-args">MAT</span></span></li>
</ul>

<p><a id='x-28MGL-MAT-3AREPLACE-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L359">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AREPLACE-21-20FUNCTION-29" >REPLACE!</a></span></span> <span class="locative-args">MAT SEQ-OF-SEQS</span></span></p>

<p>Replace the contents of <code>MAT</code> with the elements of <code>SEQ-OF-SEQS</code>.
<code>SEQ-OF-SEQS</code> is a nested sequence of sequences similar to the
<code>INITIAL-CONTENTS</code> argument of <code>MAKE-ARRAY</code>. The total number of
elements must match the size of <code>MAT</code>. Returns <code>MAT</code>.</p>

<p><code>SEQ-OF-SEQS</code> may contain multi-dimensional arrays as <em>leafs</em>, so the
following is legal:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">replace! <span class="paren2">(<span class="code">make-mat '<span class="paren3">(<span class="code">1 2 3</span>)</span></span>)</span> '<span class="paren2">(<span class="code">#2A<span class="paren3">(<span class="code"><span class="paren4">(<span class="code">1 2 3</span>)</span> <span class="paren4">(<span class="code">4 5 6</span>)</span></span>)</span></span>)</span></span>)</span>
==&gt; #&lt;MAT 1x2x3 AB #3A<span class="paren1">(<span class="code"><span class="paren2">(<span class="code"><span class="paren3">(<span class="code">1.0d0 2.0d0 3.0d0</span>)</span> <span class="paren3">(<span class="code">4.0d0 5.0d0 6.0d0</span>)</span></span>)</span></span>)</span>&gt;</span></code></pre></li>
</ul>

<p><a id='x-28MGL-MAT-3AMREF-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L408">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMREF-20FUNCTION-29" >MREF</a></span></span> <span class="locative-args">MAT &amp;REST INDICES</span></span></p>

<p>Like <code>AREF</code> for arrays. Don't use this if you care about performance
at all. SETFable. When set, the value is coerced to the ctype of <code>MAT</code>
with <a href="#x-28MGL-MAT-3ACOERCE-TO-CTYPE-20FUNCTION-29" title="(MGL-MAT:COERCE-TO-CTYPE FUNCTION)"><code>COERCE-TO-CTYPE</code></a>. Note that currently <code>MREF</code> always operates on
the <a href="#x-28MGL-MAT-3ABACKING-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:BACKING-ARRAY MGL-CUBE:FACET-NAME)"><code>BACKING-ARRAY</code></a> facet so it can trigger copying of facets. When
it's <code>SETF</code>'ed, however, it will update the <a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a> if cuda is
enabled and it is up-to-date or there are no facets at all.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AROW-MAJOR-MREF-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L443">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AROW-MAJOR-MREF-20FUNCTION-29" >ROW-MAJOR-MREF</a></span></span> <span class="locative-args">MAT INDEX</span></span></p>

<p>Like <code>ROW-MAJOR-AREF</code> for arrays. Don't use this if you care about
performance at all. SETFable. When set, the value is coerced to the
ctype of <code>MAT</code> with <a href="#x-28MGL-MAT-3ACOERCE-TO-CTYPE-20FUNCTION-29" title="(MGL-MAT:COERCE-TO-CTYPE FUNCTION)"><code>COERCE-TO-CTYPE</code></a>. Note that currently
<code>ROW-MAJOR-MREF</code> always operates on the <a href="#x-28MGL-MAT-3ABACKING-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:BACKING-ARRAY MGL-CUBE:FACET-NAME)"><code>BACKING-ARRAY</code></a> facet so it can
trigger copying of facets. When it's <code>SETF</code>'ed, however, it will
update the <a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a> if cuda is enabled and it is up-to-date or
there are no facets at all.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AMAT-ROW-MAJOR-INDEX-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L472">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAT-ROW-MAJOR-INDEX-20FUNCTION-29" >MAT-ROW-MAJOR-INDEX</a></span></span> <span class="locative-args">MAT &amp;REST SUBSCRIPTS</span></span></p>

<p>Like <code>ARRAY-ROW-MAJOR-INDEX</code> for arrays.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-CTYPES-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-BASICS-20MGL-PAX-3ASECTION-29" title="Basics">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-PRINTING-20MGL-PAX-3ASECTION-29" title="Printing">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-CTYPES-20MGL-PAX-3ASECTION-29" title="Element types">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/util.lisp#L161">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-CTYPES-20MGL-PAX-3ASECTION-29">6 Element types</a></h2>

<p><a id='x-28MGL-MAT-3A-2ASUPPORTED-CTYPES-2A-20VARIABLE-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/util.lisp#L168">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ASUPPORTED-CTYPES-2A-20VARIABLE-29" >*SUPPORTED-CTYPES*</a></span></span> <span class="locative-args">(:FLOAT :DOUBLE)</span></span></li>
</ul>

<p><a id='x-28MGL-MAT-3ACTYPE-20TYPE-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/util.lisp#L170">[type]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACTYPE-20TYPE-29" >CTYPE</a></span></span></span></p>

<p>This is basically <code>(MEMBER :FLOAT :DOUBLE)</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ADEFAULT-MAT-CTYPE-2A-20VARIABLE-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/util.lisp#L193">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ADEFAULT-MAT-CTYPE-2A-20VARIABLE-29" >*DEFAULT-MAT-CTYPE*</a></span></span> <span class="locative-args">:DOUBLE</span></span></p>

<p>By default <code>MATs</code> are created with this ctype. One of <code>:FLOAT</code>
or <code>:DOUBLE</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ACOERCE-TO-CTYPE-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/util.lisp#L197">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACOERCE-TO-CTYPE-20FUNCTION-29" >COERCE-TO-CTYPE</a></span></span> <span class="locative-args">X &amp;KEY (CTYPE <a href="#x-28MGL-MAT-3A-2ADEFAULT-MAT-CTYPE-2A-20VARIABLE-29" title="(MGL-MAT:*DEFAULT-MAT-CTYPE* VARIABLE)"><code>*DEFAULT-MAT-CTYPE*</code></a>)</span></span></p>

<p>Coerce the scalar <code>X</code> to the lisp type corresponding to <code>CTYPE</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-PRINTING-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-CTYPES-20MGL-PAX-3ASECTION-29" title="Element types">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29" title="Shaping">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-PRINTING-20MGL-PAX-3ASECTION-29" title="Printing">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L489">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-PRINTING-20MGL-PAX-3ASECTION-29">7 Printing</a></h2>

<p><a id='x-28MGL-MAT-3A-2APRINT-MAT-2A-20VARIABLE-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L493">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2APRINT-MAT-2A-20VARIABLE-29" >*PRINT-MAT*</a></span></span> <span class="locative-args">T</span></span></p>

<p>Controls whether the contents of a <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> object are printed as an
array (subject to the standard printer control variables).</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2APRINT-MAT-FACETS-2A-20VARIABLE-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L497">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2APRINT-MAT-FACETS-2A-20VARIABLE-29" >*PRINT-MAT-FACETS*</a></span></span> <span class="locative-args">T</span></span></p>

<p>Controls whether a summary of existing and up-to-date facets is
printed when a <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> object is printed. The summary that looks like
<code>ABcfh</code> indicates that all five facets (<a href="#x-28ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(ARRAY MGL-CUBE:FACET-NAME)"><code>ARRAY</code></a>,
<a href="#x-28MGL-MAT-3ABACKING-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:BACKING-ARRAY MGL-CUBE:FACET-NAME)"><code>BACKING-ARRAY</code></a>, <a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a>,
<a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:FOREIGN-ARRAY MGL-CUBE:FACET-NAME)"><code>FOREIGN-ARRAY</code></a>, <a href="#x-28MGL-MAT-3ACUDA-HOST-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-HOST-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-HOST-ARRAY</code></a>) are
present and the first two are up-to-date. A summary of a single #-
indicates that there are no facets.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-PRINTING-20MGL-PAX-3ASECTION-29" title="Printing">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-COMPARISON-TO-LISP-20MGL-PAX-3ASECTION-29" title="Comparison to Lisp Arrays">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29" title="Shaping">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L553">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29">8 Shaping</a></h2>

<p>We are going to discuss various ways to change the visible portion
and dimensions of matrices. Conceptually a matrix has an <em>underlying
non-displaced storage vector</em>. For <code>(MAKE-MAT 10 :DISPLACEMENT
7 :MAX-SIZE 21)</code> this underlying vector looks like this:</p>

<pre><code>displacement | visible elements  | slack
. . . . . . . 0 0 0 0 0 0 0 0 0 0 . . . .
</code></pre>

<p>Whenever a matrix is reshaped (or <em>displaced to</em> in lisp
terminology), its displacement and dimensions change but the
underlying vector does not.</p>

<p>The rules for accessing displaced matrices is the same as always:
multiple readers can run in parallel, but attempts to write will
result in an error if there are either readers or writers on any of
the matrices that share the same underlying vector.</p>

<p><a id='x-28MGL-MAT-3A-40MAT-SHAPING-COMPARISON-TO-LISP-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29" title="Shaping">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29" title="Shaping">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-FUNCTIONAL-20MGL-PAX-3ASECTION-29" title="Functional Shaping">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-COMPARISON-TO-LISP-20MGL-PAX-3ASECTION-29" title="Comparison to Lisp Arrays">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L574">&#955;</a></span></span></p>

<h3><a href="#x-28MGL-MAT-3A-40MAT-SHAPING-COMPARISON-TO-LISP-20MGL-PAX-3ASECTION-29">8.1 Comparison to Lisp Arrays</a></h3>

<p>One way to reshape and displace <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> objects is with <a href="#x-28MGL-MAT-3AMAKE-MAT-20FUNCTION-29" title="(MGL-MAT:MAKE-MAT FUNCTION)"><code>MAKE-MAT</code></a> and
its <code>DISPLACED-TO</code> argument whose semantics are similar to that of
<code>MAKE-ARRAY</code> in that the displacement is <em>relative</em> to the
displacement of <code>DISPLACED-TO</code>.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let*</span></i></a> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">base <span class="paren4">(<span class="code">make-mat 10 <span class="keyword">:initial-element</span> 5 <span class="keyword">:displacement</span> 1</span>)</span></span>)</span>
       <span class="paren3">(<span class="code">mat <span class="paren4">(<span class="code">make-mat 6 <span class="keyword">:displaced-to</span> base <span class="keyword">:displacement</span> 2</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">fill! 1 mat</span>)</span>
  <span class="paren2">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_values.htm" class="symbol">values</a> base mat</span>)</span></span>)</span>
==&gt; #&lt;MAT 1+10+0 A #<span class="paren1">(<span class="code">5.0d0 5.0d0 1.0d0 1.0d0 1.0d0 1.0d0 1.0d0 1.0d0 5.0d0
--&gt;                  5.0d0</span>)</span>&gt;
==&gt; #&lt;MAT 3+6+2 AB #<span class="paren1">(<span class="code">1.0d0 1.0d0 1.0d0 1.0d0 1.0d0 1.0d0</span>)</span>&gt;</span></code></pre>

<p>There are important semantic differences compared to lisp arrays all
which follow from the fact that displacement operates on the
underlying conceptual non-displaced vector.</p>

<ul>
<li><p>Matrices can be displaced and have slack even without <code>DISPLACED-TO</code>
  just like <code>BASE</code> in the above example.</p></li>
<li><p>It's legal to alias invisible elements of <code>DISPLACED-TO</code> as long as
  the new matrix fits into the underlying storage.</p></li>
<li><p>Negative displacements are allowed with <code>DISPLACED-TO</code> as long as
  the adjusted displacement is non-negative.</p></li>
<li><p>Further shaping operations can make invisible portions of the
  <code>DISPLACED-TO</code> matrix visible by changing the displacement.</p></li>
<li><p>In contrast to <code>ARRAY-DISPLACEMENT</code>, <a href="#x-28MGL-MAT-3AMAT-DISPLACEMENT-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-DISPLACEMENT (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-DISPLACEMENT</code></a> only returns
  an offset into the underlying storage vector.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-SHAPING-FUNCTIONAL-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-COMPARISON-TO-LISP-20MGL-PAX-3ASECTION-29" title="Comparison to Lisp Arrays">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29" title="Shaping">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-DESTRUCTIVE-20MGL-PAX-3ASECTION-29" title="Destructive Shaping">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-FUNCTIONAL-20MGL-PAX-3ASECTION-29" title="Functional Shaping">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L610">&#955;</a></span></span></p>

<h3><a href="#x-28MGL-MAT-3A-40MAT-SHAPING-FUNCTIONAL-20MGL-PAX-3ASECTION-29">8.2 Functional Shaping</a></h3>

<p>The following functions are collectively called the functional
shaping operations, since they don't alter their arguments in any
way. Still, since storage is aliased modification to the returned
matrix will affect the original.</p>

<p><a id='x-28MGL-MAT-3ARESHAPE-AND-DISPLACE-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L619">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ARESHAPE-AND-DISPLACE-20FUNCTION-29" >RESHAPE-AND-DISPLACE</a></span></span> <span class="locative-args">MAT DIMENSIONS DISPLACEMENT</span></span></p>

<p>Return a new matrix of <code>DIMENSIONS</code> that aliases <code>MAT</code>'s storage at
offset <code>DISPLACEMENT</code>. <code>DISPLACEMENT</code> 0 is equivalent to the start of
the storage of <code>MAT</code> regardless of <code>MAT</code>'s displacement.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ARESHAPE-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L627">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ARESHAPE-20FUNCTION-29" >RESHAPE</a></span></span> <span class="locative-args">MAT DIMENSIONS</span></span></p>

<p>Return a new matrix of <code>DIMENSIONS</code> whose displacement is the same as
the displacement of <code>MAT</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ADISPLACE-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L632">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ADISPLACE-20FUNCTION-29" >DISPLACE</a></span></span> <span class="locative-args">MAT DISPLACEMENT</span></span></p>

<p>Return a new matrix that aliases <code>MAT</code>'s storage at offset
<code>DISPLACEMENT</code>. <code>DISPLACEMENT</code> 0 is equivalent to the start of the
storage of <code>MAT</code> regardless of <code>MAT</code>'s displacement. The returned matrix
has the same dimensions as <code>MAT</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-SHAPING-DESTRUCTIVE-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-FUNCTIONAL-20MGL-PAX-3ASECTION-29" title="Functional Shaping">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29" title="Shaping">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-ASSEMBLING-20MGL-PAX-3ASECTION-29" title="Assembling">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-DESTRUCTIVE-20MGL-PAX-3ASECTION-29" title="Destructive Shaping">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L642">&#955;</a></span></span></p>

<h3><a href="#x-28MGL-MAT-3A-40MAT-SHAPING-DESTRUCTIVE-20MGL-PAX-3ASECTION-29">8.3 Destructive Shaping</a></h3>

<p>The following destructive operations don't alter the contents of
the matrix, but change what is visible. <a href="#x-28MGL-MAT-3AADJUST-21-20FUNCTION-29" title="(MGL-MAT:ADJUST! FUNCTION)"><code>ADJUST!</code></a> is the odd one out,
it may create a new <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a>.</p>

<p><a id='x-28MGL-MAT-3ARESHAPE-AND-DISPLACE-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L653">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ARESHAPE-AND-DISPLACE-21-20FUNCTION-29" >RESHAPE-AND-DISPLACE!</a></span></span> <span class="locative-args">MAT DIMENSIONS DISPLACEMENT</span></span></p>

<p>Change the visible (or active) portion of <code>MAT</code> by altering its
displacement offset and dimensions. Future operations will only
affect this visible portion as if the rest of the elements were not
there. Return <code>MAT</code>.</p>

<p><code>DISPLACEMENT</code> + the new size must not exceed <a href="#x-28MGL-MAT-3AMAT-MAX-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-MAX-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-MAX-SIZE</code></a>.
Furthermore, there must be no facets being viewed (with <a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACETS-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACETS MGL-PAX:MACRO)"><code>WITH-FACETS</code></a>)
when calling this function as the identity of the facets is not
stable.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ARESHAPE-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L685">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ARESHAPE-21-20FUNCTION-29" >RESHAPE!</a></span></span> <span class="locative-args">MAT DIMENSIONS</span></span></p>

<p>Like <a href="#x-28MGL-MAT-3ARESHAPE-AND-DISPLACE-21-20FUNCTION-29" title="(MGL-MAT:RESHAPE-AND-DISPLACE! FUNCTION)"><code>RESHAPE-AND-DISPLACE!</code></a> but only alters the dimensions.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ADISPLACE-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L689">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ADISPLACE-21-20FUNCTION-29" >DISPLACE!</a></span></span> <span class="locative-args">MAT DISPLACEMENT</span></span></p>

<p>Like <a href="#x-28MGL-MAT-3ARESHAPE-AND-DISPLACE-21-20FUNCTION-29" title="(MGL-MAT:RESHAPE-AND-DISPLACE! FUNCTION)"><code>RESHAPE-AND-DISPLACE!</code></a> but only alters the displacement.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ARESHAPE-TO-ROW-MATRIX-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L693">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ARESHAPE-TO-ROW-MATRIX-21-20FUNCTION-29" >RESHAPE-TO-ROW-MATRIX!</a></span></span> <span class="locative-args">MAT ROW</span></span></p>

<p>Reshape the 2d <code>MAT</code> to make only a single <code>ROW</code> visible. This is made
possible by the row-major layout, hence no column counterpart.
Return <code>MAT</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AWITH-SHAPE-AND-DISPLACEMENT-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L713">[macro]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AWITH-SHAPE-AND-DISPLACEMENT-20MGL-PAX-3AMACRO-29" >WITH-SHAPE-AND-DISPLACEMENT</a></span></span> <span class="locative-args">(MAT &amp;OPTIONAL (DIMENSIONS <code>NIL</code>) (DISPLACEMENT <code>NIL</code>)) &amp;BODY BODY</span></span></p>

<p>Reshape and displace <code>MAT</code> if <code>DIMENSIONS</code> and/or <code>DISPLACEMENT</code> is given
and restore the original shape and displacement after <code>BODY</code> is
executed. If neither is specificed, then nothing will be changed,
but <code>BODY</code> is still allowed to alter the shape and displacement.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AADJUST-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L730">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AADJUST-21-20FUNCTION-29" >ADJUST!</a></span></span> <span class="locative-args">MAT DIMENSIONS DISPLACEMENT &amp;KEY (DESTROY-OLD-P <code>T</code>)</span></span></p>

<p>Like <a href="#x-28MGL-MAT-3ARESHAPE-AND-DISPLACE-21-20FUNCTION-29" title="(MGL-MAT:RESHAPE-AND-DISPLACE! FUNCTION)"><code>RESHAPE-AND-DISPLACE!</code></a> but creates a new matrix if <code>MAT</code> isn't
large enough. If a new matrix is created, the contents are not
copied over and the old matrix is destroyed with <a href="cube-manual.html#x-28MGL-CUBE-3ADESTROY-CUBE-20FUNCTION-29" title="(MGL-CUBE:DESTROY-CUBE FUNCTION)"><code>DESTROY-CUBE</code></a> if
<code>DESTROY-OLD-P</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-ASSEMBLING-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-DESTRUCTIVE-20MGL-PAX-3ASECTION-29" title="Destructive Shaping">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-CACHING-20MGL-PAX-3ASECTION-29" title="Caching">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-ASSEMBLING-20MGL-PAX-3ASECTION-29" title="Assembling">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L747">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-ASSEMBLING-20MGL-PAX-3ASECTION-29">9 Assembling</a></h2>

<p>The functions here assemble a single <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> from a number of
<a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a>s.</p>

<p><a id='x-28MGL-MAT-3ASTACK-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L753">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ASTACK-21-20FUNCTION-29" >STACK!</a></span></span> <span class="locative-args">AXIS MATS MAT</span></span></p>

<p>Stack <code>MATS</code> along <code>AXIS</code> into <code>MAT</code> and return <code>MAT</code>. If <code>AXIS</code> is 0, place
<code>MATS</code> into <code>MAT</code> below each other starting from the top. If <code>AXIS</code> is 1,
place <code>MATS</code> side by side starting from the left. Higher <code>AXIS</code> are also
supported. All dimensions except for <code>AXIS</code> must be the same for all
<code>MATS</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ASTACK-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L769">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ASTACK-20FUNCTION-29" >STACK</a></span></span> <span class="locative-args">AXIS MATS &amp;KEY (CTYPE <a href="#x-28MGL-MAT-3A-2ADEFAULT-MAT-CTYPE-2A-20VARIABLE-29" title="(MGL-MAT:*DEFAULT-MAT-CTYPE* VARIABLE)"><code>*DEFAULT-MAT-CTYPE*</code></a>)</span></span></p>

<p>Like <a href="#x-28MGL-MAT-3ASTACK-21-20FUNCTION-29" title="(MGL-MAT:STACK! FUNCTION)"><code>STACK!</code></a> but return a new <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> of <code>CTYPE</code>.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">stack 1 <span class="paren2">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> <span class="paren3">(<span class="code">make-mat '<span class="paren4">(<span class="code">3 2</span>)</span> <span class="keyword">:initial-element</span> 0</span>)</span>
               <span class="paren3">(<span class="code">make-mat '<span class="paren4">(<span class="code">3 1</span>)</span> <span class="keyword">:initial-element</span> 1</span>)</span></span>)</span></span>)</span>
==&gt; #&lt;MAT 3x3 B #2A<span class="paren1">(<span class="code"><span class="paren2">(<span class="code">0.0d0 0.0d0 1.0d0</span>)</span>
--&gt;                 <span class="paren2">(<span class="code">0.0d0 0.0d0 1.0d0</span>)</span>
--&gt;                 <span class="paren2">(<span class="code">0.0d0 0.0d0 1.0d0</span>)</span></span>)</span>&gt;</span></code></pre></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-CACHING-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-ASSEMBLING-20MGL-PAX-3ASECTION-29" title="Assembling">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-BLAS-20MGL-PAX-3ASECTION-29" title="BLAS Operations">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-CACHING-20MGL-PAX-3ASECTION-29" title="Caching">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L790">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-CACHING-20MGL-PAX-3ASECTION-29">10 Caching</a></h2>

<p>Allocating and initializing a <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> object and its necessary facets
can be expensive. The following macros remember the previous value
of a binding in the same thread and /place/. Only weak references
are constructed so the cached objects can be garbage collected.</p>

<p>While the cache is global, thread safety is guaranteed by having
separate subcaches per thread. Each subcache is keyed by a /place/
object that's either explicitly specified or else is unique to each
invocation of the caching macro, so different occurrences of caching
macros in the source never share data. Still, recursion could lead
to data sharing between different invocations of the same function.
To prevent this, the cached object is removed from the cache while
it is used so other invocations will create a fresh one which isn't
particularly efficient but at least it's safe.</p>

<p><a id='x-28MGL-MAT-3AWITH-THREAD-CACHED-MAT-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L810">[macro]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AWITH-THREAD-CACHED-MAT-20MGL-PAX-3AMACRO-29" >WITH-THREAD-CACHED-MAT</a></span></span> <span class="locative-args">(VAR DIMENSIONS &amp;REST ARGS &amp;KEY (PLACE <code>:SCRATCH</code>) (CTYPE '<a href="#x-28MGL-MAT-3A-2ADEFAULT-MAT-CTYPE-2A-20VARIABLE-29" title="(MGL-MAT:*DEFAULT-MAT-CTYPE* VARIABLE)"><code>*DEFAULT-MAT-CTYPE*</code></a>) (DISPLACEMENT 0) MAX-SIZE (INITIAL-ELEMENT 0) INITIAL-CONTENTS) &amp;BODY BODY</span></span></p>

<p>Bind <code>VAR</code> to a matrix of <code>DIMENSIONS</code>, <code>CTYPE</code>, etc. Cache this matrix,
and possibly reuse it later by reshaping it. When <code>BODY</code> exits the
cached object is updated with the binding of <code>VAR</code> which <code>BODY</code> may
change.</p>

<p>There is a separate cache for each thread and each <code>PLACE</code> (under
EQ). Since every cache holds exactly one <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> per <code>CTYPE</code>, nested
<code>WITH-THREAD-CACHED-MAT</code> often want to use different <code>PLACE</code>s. By
convention, these places are called <code>:SCRATCH-1</code>, <code>:SCRATCH-2</code>,
etc.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AWITH-THREAD-CACHED-MATS-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L846">[macro]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AWITH-THREAD-CACHED-MATS-20MGL-PAX-3AMACRO-29" >WITH-THREAD-CACHED-MATS</a></span></span> <span class="locative-args">SPECS &amp;BODY BODY</span></span></p>

<p>A shorthand for writing nested <a href="#x-28MGL-MAT-3AWITH-THREAD-CACHED-MAT-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-THREAD-CACHED-MAT MGL-PAX:MACRO)"><code>WITH-THREAD-CACHED-MAT</code></a> calls.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">with-thread-cached-mat</span></i> <span class="paren2">(<span class="code">a ...</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">with-thread-cached-mat</span></i> <span class="paren3">(<span class="code">b ...</span>)</span>
    ...</span>)</span></span>)</span></span></code></pre>

<p>is equivalent to:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">with-thread-cached-mat</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">a ...</span>)</span>
                         <span class="paren3">(<span class="code">b ...</span>)</span></span>)</span>
  ...</span>)</span></span></code></pre></li>
</ul>

<p><a id='x-28MGL-MAT-3AWITH-ONES-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L869">[macro]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AWITH-ONES-20MGL-PAX-3AMACRO-29" >WITH-ONES</a></span></span> <span class="locative-args">(VAR DIMENSIONS &amp;KEY (CTYPE '<a href="#x-28MGL-MAT-3A-2ADEFAULT-MAT-CTYPE-2A-20VARIABLE-29" title="(MGL-MAT:*DEFAULT-MAT-CTYPE* VARIABLE)"><code>*DEFAULT-MAT-CTYPE*</code></a>) (PLACE <code>:ONES</code>)) &amp;BODY BODY</span></span></p>

<p>Bind <code>VAR</code> to a matrix of <code>DIMENSIONS</code> whose every element is 1. The
matrix is cached for efficiency.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-BLAS-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-CACHING-20MGL-PAX-3ASECTION-29" title="Caching">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29" title="Destructive API">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-BLAS-20MGL-PAX-3ASECTION-29" title="BLAS Operations">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1462">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-BLAS-20MGL-PAX-3ASECTION-29">11 BLAS Operations</a></h2>

<p>Only some BLAS functions are implemented, but it should be easy to
add more as needed. All of them default to using CUDA, if it is
initialized and enabled (see <a href="#x-28MGL-MAT-3AUSE-CUDA-P-20FUNCTION-29" title="(MGL-MAT:USE-CUDA-P FUNCTION)"><code>USE-CUDA-P</code></a>).</p>

<p>Level 1 BLAS operations</p>

<p><a id='x-28MGL-MAT-3AASUM-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1478">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AASUM-20FUNCTION-29" >ASUM</a></span></span> <span class="locative-args">X &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X)) (INCX 1)</span></span></p>

<p>Return the l1 norm of <code>X</code>, that is, sum of the absolute values of its
elements.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AAXPY-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1486">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AAXPY-21-20FUNCTION-29" >AXPY!</a></span></span> <span class="locative-args">ALPHA X Y &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X)) (INCX 1) (INCY 1)</span></span></p>

<p>Set <code>Y</code> to <code>ALPHA</code> * <code>X</code> + <code>Y</code>. Return <code>Y</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ACOPY-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1495">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACOPY-21-20FUNCTION-29" >COPY!</a></span></span> <span class="locative-args">X Y &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X)) (INCX 1) (INCY 1)</span></span></p>

<p>Copy <code>X</code> into <code>Y</code>. Return <code>Y</code>.</p></li>
</ul>

<p><a id='x-28CL-CUDA-2ELANG-2EBUILT-IN-3ADOT-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1504">[function]</a></span> <span class="reference-object"><a href="#x-28CL-CUDA-2ELANG-2EBUILT-IN-3ADOT-20FUNCTION-29" >DOT</a></span></span> <span class="locative-args">X Y &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X)) (INCX 1) (INCY 1)</span></span></p>

<p>Return the dot product of <code>X</code> and <code>Y</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ANRM2-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1512">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ANRM2-20FUNCTION-29" >NRM2</a></span></span> <span class="locative-args">X &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X)) (INCX 1)</span></span></p>

<p>Return the l2 norm of <code>X</code>, which is the square root of the sum of the
squares of its elements.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ASCAL-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1520">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ASCAL-21-20FUNCTION-29" >SCAL!</a></span></span> <span class="locative-args">ALPHA X &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X)) (INCX 1)</span></span></p>

<p>Set <code>X</code> to <code>ALPHA</code> * <code>X</code>. Return <code>X</code>.</p></li>
</ul>

<p>Level 3 BLAS operations</p>

<p><a id='x-28MGL-MAT-3AGEMM-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1530">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AGEMM-21-20FUNCTION-29" >GEMM!</a></span></span> <span class="locative-args">ALPHA A B BETA C &amp;KEY TRANSPOSE-A? TRANSPOSE-B? M N K LDA LDB LDC</span></span></p>

<p>Basically <code>C</code> = <code>ALPHA</code> * <code>A</code>' * <code>B</code>' + <code>BETA</code> * <code>C</code>. <code>A</code>' is <code>A</code> or its transpose
depending on <code>TRANSPOSE-A?</code>. <code>B</code>' is <code>B</code> or its transpose depending on
<code>TRANSPOSE-B?</code>. Returns <code>C</code>.</p>

<p><code>A</code>' is an MxK matrix. <code>B</code>' is a KxN matrix. <code>C</code> is an MxN matrix.</p>

<p><code>LDA</code> is the width of the matrix <code>A</code> (not of <code>A</code>'). If <code>A</code> is not transposed,
then <code>K</code> &lt;= <code>LDA</code>, if it's transposed then <code>M</code> &lt;= <code>LDA</code>.</p>

<p><code>LDB</code> is the width of the matrix <code>B</code> (not of <code>B</code>'). If <code>B</code> is not transposed,
then <code>N</code> &lt;= <code>LDB</code>, if it's transposed then <code>K</code> &lt;= <code>LDB</code>.</p>

<p>In the example below M=3, N=2, K=5, LDA=6, LDB=3, LDC=4. The cells
marked with + do not feature in the calculation.</p>

<pre><code>           N
          --+
          --+
        K -B+
          --+
          --+
          +++
    K
  -----+  --++
M --A--+  -C++
  -----+  --++
  ++++++  ++++
</code></pre></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-BLAS-20MGL-PAX-3ASECTION-29" title="BLAS Operations">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-NON-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29" title="Non-destructive API">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29" title="Destructive API">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L933">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29">12 Destructive API</a></h2>

<p><a id='x-28MGL-MAT-3A-2ESQUARE-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L965">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ESQUARE-21-20FUNCTION-29" >.SQUARE!</a></span></span> <span class="locative-args">X &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X))</span></span></p>

<p>Set <code>X</code> to its elementwise square. Return <code>X</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ESQRT-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L970">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ESQRT-21-20FUNCTION-29" >.SQRT!</a></span></span> <span class="locative-args">X &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X))</span></span></p>

<p>Set <code>X</code> to its elementwise square root. Return <code>X</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ELOG-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L975">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ELOG-21-20FUNCTION-29" >.LOG!</a></span></span> <span class="locative-args">X &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X))</span></span></p>

<p>Set <code>X</code> to its elementwise natural logarithm. Return <code>X</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2EEXP-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L980">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2EEXP-21-20FUNCTION-29" >.EXP!</a></span></span> <span class="locative-args">X &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X))</span></span></p>

<p>Apply <code>EXP</code> elementwise to <code>X</code> in a destructive manner. Return <code>X</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2EEXPT-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L997">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2EEXPT-21-20FUNCTION-29" >.EXPT!</a></span></span> <span class="locative-args">X POWER</span></span></p>

<p>Raise matrix <code>X</code> to <code>POWER</code> in an elementwise manner. Return <code>X</code>. Note
that CUDA and non-CUDA implementations may disagree on the treatment
of NaNs, infinities and complex results. In particular, the lisp
implementation always computes the <code>REALPART</code> of the results while
CUDA's pow() returns NaNs instead of complex numbers.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2EINV-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L985">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2EINV-21-20FUNCTION-29" >.INV!</a></span></span> <span class="locative-args">X &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X))</span></span></p>

<p>Set <code>X</code> to its elementwise inverse <code>(/ 1 X)</code>. Return <code>X</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ELOGISTIC-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L990">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ELOGISTIC-21-20FUNCTION-29" >.LOGISTIC!</a></span></span> <span class="locative-args">X &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X))</span></span></p>

<p>Destructively apply the logistic function to <code>X</code> in an elementwise
manner. Return <code>X</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2E-2B-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1044">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2E-2B-21-20FUNCTION-29" >.+!</a></span></span> <span class="locative-args">ALPHA X</span></span></p>

<p>Add the scalar <code>ALPHA</code> to each element of <code>X</code> destructively modifying
<code>X</code>. Return <code>X</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2E-2A-21-20FUNCTION-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1055">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2E-2A-21-20FUNCTION-29" >.*!</a></span></span> <span class="locative-args">X Y</span></span></li>
</ul>

<p><a id='x-28MGL-MAT-3AGEEM-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1058">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AGEEM-21-20FUNCTION-29" >GEEM!</a></span></span> <span class="locative-args">ALPHA A B BETA C</span></span></p>

<p>Like <a href="#x-28MGL-MAT-3AGEMM-21-20FUNCTION-29" title="(MGL-MAT:GEMM! FUNCTION)"><code>GEMM!</code></a>, but multiplication is elementwise. This is not a
standard BLAS routine.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AGEERV-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1097">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AGEERV-21-20FUNCTION-29" >GEERV!</a></span></span> <span class="locative-args">ALPHA A X BETA B</span></span></p>

<p>GEneric Elementwise Row - Vector multiplication. <code>B = beta * B +
alpha a .* X*</code> where <code>X*</code> is a matrix of the same shape as <code>A</code> whose
every row is <code>X</code>. Perform elementwise multiplication on each row of <code>A</code>
with the vector <code>X</code> and add the scaled result to the corresponding row
of <code>B</code>. Return <code>B</code>. This is not a standard BLAS routine.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2E-3C-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1166">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2E-3C-21-20FUNCTION-29" >.&lt;!</a></span></span> <span class="locative-args">X Y</span></span></p>

<p>For each element of <code>X</code> and <code>Y</code> set <code>Y</code> to 1 if the element in <code>Y</code> is
greater than the element in <code>X</code>, and to 0 otherwise. Return <code>Y</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2EMIN-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1177">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2EMIN-21-20FUNCTION-29" >.MIN!</a></span></span> <span class="locative-args">ALPHA X</span></span></p>

<p>Set each element of <code>X</code> to <code>ALPHA</code> if it's greater than <code>ALPHA</code>. Return
<code>X</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2EMAX-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1205">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2EMAX-21-20FUNCTION-29" >.MAX!</a></span></span> <span class="locative-args">ALPHA X</span></span></p>

<p>Set each element of <code>X</code> to <code>ALPHA</code> if it's less than <code>ALPHA</code>. Return <code>X</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AADD-SIGN-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1262">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AADD-SIGN-21-20FUNCTION-29" >ADD-SIGN!</a></span></span> <span class="locative-args">ALPHA A BETA B</span></span></p>

<p>Add the elementwise sign (-1, 0 or 1 for negative, zero and
positive numbers respectively) of <code>A</code> times <code>ALPHA</code> to <code>BETA</code> * <code>B</code>. Return
<code>B</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AFILL-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1298">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AFILL-21-20FUNCTION-29" >FILL!</a></span></span> <span class="locative-args">ALPHA X &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X))</span></span></p>

<p>Fill matrix <code>X</code> with <code>ALPHA</code>. Return <code>X</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ASUM-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1320">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ASUM-21-20FUNCTION-29" >SUM!</a></span></span> <span class="locative-args">X Y &amp;KEY AXIS (ALPHA 1) (BETA 0)</span></span></p>

<p>Sum matrix <code>X</code> along <code>AXIS</code> and add <code>ALPHA</code> * <code>SUM</code>S to <code>BETA</code> * <code>Y</code>
destructively modifying <code>Y</code>. Return <code>Y</code>. On a 2d matrix (nothing else is
supported currently), if <code>AXIS</code> is 0, then columns are summed, if <code>AXIS</code>
is 1 then rows are summed.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ASCALE-ROWS-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1346">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ASCALE-ROWS-21-20FUNCTION-29" >SCALE-ROWS!</a></span></span> <span class="locative-args">SCALES A &amp;KEY (RESULT A)</span></span></p>

<p>Set <code>RESULT</code> to <code>DIAG(SCALES)*A</code> and return it. <code>A</code> is an <code>MxN</code>
matrix, <code>SCALES</code> is treated as a length <code>M</code> vector.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ASCALE-COLUMNS-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1389">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ASCALE-COLUMNS-21-20FUNCTION-29" >SCALE-COLUMNS!</a></span></span> <span class="locative-args">SCALES A &amp;KEY (RESULT A)</span></span></p>

<p>Set <code>RESULT</code> to <code>A*DIAG(SCALES)</code> and return it. <code>A</code> is an <code>MxN</code>
matrix, <code>SCALES</code> is treated as a length <code>N</code> vector.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ESIN-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1431">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ESIN-21-20FUNCTION-29" >.SIN!</a></span></span> <span class="locative-args">X &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X))</span></span></p>

<p>Apply <code>SIN</code> elementwise to <code>X</code> in a destructive manner. Return <code>X</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ECOS-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1436">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ECOS-21-20FUNCTION-29" >.COS!</a></span></span> <span class="locative-args">X &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X))</span></span></p>

<p>Apply <code>COS</code> elementwise to <code>X</code> in a destructive manner. Return <code>X</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ETAN-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1441">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ETAN-21-20FUNCTION-29" >.TAN!</a></span></span> <span class="locative-args">X &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X))</span></span></p>

<p>Apply <code>TAN</code> elementwise to <code>X</code> in a destructive manner. Return <code>X</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ESINH-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1446">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ESINH-21-20FUNCTION-29" >.SINH!</a></span></span> <span class="locative-args">X &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X))</span></span></p>

<p>Apply <code>SINH</code> elementwise to <code>X</code> in a destructive manner. Return <code>X</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ECOSH-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1451">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ECOSH-21-20FUNCTION-29" >.COSH!</a></span></span> <span class="locative-args">X &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X))</span></span></p>

<p>Apply <code>COSH</code> elementwise to <code>X</code> in a destructive manner. Return <code>X</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ETANH-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1456">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ETANH-21-20FUNCTION-29" >.TANH!</a></span></span> <span class="locative-args">X &amp;KEY (N (<a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> X))</span></span></p>

<p>Apply <code>TANH</code> elementwise to <code>X</code> in a destructive manner. Return <code>X</code>.</p></li>
</ul>

<p>Finally, some neural network operations.</p>

<p><a id='x-28MGL-MAT-3ACONVOLVE-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/convolve.lisp#L164">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACONVOLVE-21-20FUNCTION-29" >CONVOLVE!</a></span></span> <span class="locative-args">X W Y &amp;KEY START STRIDE ANCHOR BATCHED</span></span></p>

<p><code>Y</code> = <code>Y</code> + conv(<code>X</code>, <code>W</code>) and return <code>Y</code>. If <code>BATCHED</code>, then the first
dimension of <code>X</code> and <code>Y</code> is the number of elements in the batch (B),
else B is assumed to be 1. The rest of the dimensions encode the
input (<code>X</code>) and output (Y} N dimensional feature maps. <code>START</code>, <code>STRIDE</code>
and <code>ANCHOR</code> are lists of length N. <code>START</code> is the multi-dimensional
index of the first element of the input feature map (for each
element in the batch) for which the convolution must be computed.
Then (<code>ELT</code> <code>STRIDE</code> (- N 1)) is added to the last element of <code>START</code> and
so on until (<code>ARRAY-DIMENSION</code> <code>X</code> 1) is reached. Then the last element
of <code>START</code> is reset, (<code>ELT</code> <code>STRIDE</code> (- N 2)) is added to the first but
last element of <code>START</code> and we scan the last dimension again. Take a
2d example, <code>START</code> is (0 0), <code>STRIDE</code> is (1 2), and <code>X</code> is a B*2x7
matrix.</p>

<p><code>W</code> is:</p>

<pre><code>1 2 1
2 4 2
1 2 1
</code></pre>

<p>and <code>ANCHOR</code> is (1 1) which refers to the element of <code>W</code> whose value is
4. This anchor point of <code>W</code> is placed over elements of <code>X</code> whose multi
dimensional index is in numbers in this figure (only one element in
the batch is shown):</p>

<pre><code>0,0 . 0,2 . 0,4 . 0,6
1,0 . 1,2 . 1,4 . 1,6
</code></pre>

<p>When applying <code>W</code> at position P of <code>X</code>, the convolution is the sum of
the products of overlapping elements of <code>X</code> and <code>W</code> when <code>W</code>'s <code>ANCHOR</code> is
placed at P. Elements of <code>W</code> over the edges of <code>X</code> are multiplied with 0
so are effectively ignored. The order of application of <code>W</code> to
positions defined by <code>START</code>, <code>STRIDE</code> and <code>ANCHOR</code> is undefined.</p>

<p><code>Y</code> must be a B*2x4 (or 2x4 if not <code>BATCHED</code>) matrix in this example,
just large enough to hold the results of the convolutions.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ADERIVE-CONVOLVE-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/convolve.lisp#L385">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ADERIVE-CONVOLVE-21-20FUNCTION-29" >DERIVE-CONVOLVE!</a></span></span> <span class="locative-args">X XD W WD YD &amp;KEY START STRIDE ANCHOR BATCHED</span></span></p>

<p>Add the dF/dX to <code>XD</code> and and dF/dW to <code>WD</code> where <code>YD</code> is dF/dY for some
function F where Y is the result of convolution with the same
arguments. </p></li>
</ul>

<p><a id='x-28MGL-MAT-3AMAX-POOL-21-20FUNCTION-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/max-pool.lisp#L139">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAX-POOL-21-20FUNCTION-29" >MAX-POOL!</a></span></span> <span class="locative-args">X Y &amp;KEY START STRIDE ANCHOR BATCHED POOL-DIMENSIONS</span></span></li>
</ul>

<p><a id='x-28MGL-MAT-3ADERIVE-MAX-POOL-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/max-pool.lisp#L318">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ADERIVE-MAX-POOL-21-20FUNCTION-29" >DERIVE-MAX-POOL!</a></span></span> <span class="locative-args">X XD Y YD &amp;KEY START STRIDE ANCHOR BATCHED POOL-DIMENSIONS</span></span></p>

<p>Add the dF/dX to <code>XD</code> and and dF/dW to WD where <code>YD</code> is dF/dY for some
function F where <code>Y</code> is the result of <a href="#x-28MGL-MAT-3AMAX-POOL-21-20FUNCTION-29" title="(MGL-MAT:MAX-POOL! FUNCTION)"><code>MAX-POOL!</code></a> with the same
arguments. </p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-NON-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29" title="Destructive API">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-MAPPINGS-20MGL-PAX-3ASECTION-29" title="Mappings">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-NON-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29" title="Non-destructive API">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1601">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-NON-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29">13 Non-destructive API</a></h2>

<p><a id='x-28MGL-MAT-3ACOPY-MAT-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1616">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACOPY-MAT-20FUNCTION-29" >COPY-MAT</a></span></span> <span class="locative-args">A</span></span></p>

<p>Return a copy of the active portion with regards to displacement
and shape of <code>A</code>. </p></li>
</ul>

<p><a id='x-28MGL-MAT-3ACOPY-ROW-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1622">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACOPY-ROW-20FUNCTION-29" >COPY-ROW</a></span></span> <span class="locative-args">A ROW</span></span></p>

<p>Return <code>ROW</code> of <code>A</code> as a new 1d matrix.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ACOPY-COLUMN-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1631">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACOPY-COLUMN-20FUNCTION-29" >COPY-COLUMN</a></span></span> <span class="locative-args">A COLUMN</span></span></p>

<p>Return <code>COLUMN</code> of <code>A</code> as a new 1d matrix.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AMAT-AS-SCALAR-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1639">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAT-AS-SCALAR-20FUNCTION-29" >MAT-AS-SCALAR</a></span></span> <span class="locative-args">A</span></span></p>

<p>Return the first element of <code>A</code>. <code>A</code> must be of size 1.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ASCALAR-AS-MAT-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1645">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ASCALAR-AS-MAT-20FUNCTION-29" >SCALAR-AS-MAT</a></span></span> <span class="locative-args">X &amp;KEY (CTYPE (<code>LISP-&gt;CTYPE</code> (<code>TYPE-OF</code> X)))</span></span></p>

<p>Return a matrix of one dimension and one element: <code>X</code>. <code>CTYPE</code>, the
type of the matrix, defaults to the ctype corresponding to the type
of <code>X</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AM-3D-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1651">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AM-3D-20FUNCTION-29" >M=</a></span></span> <span class="locative-args">A B</span></span></p>

<p>Check whether <code>A</code> and <code>B</code>, which must be matrices of the same size, are
elementwise equal.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ATRANSPOSE-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1666">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ATRANSPOSE-20FUNCTION-29" >TRANSPOSE</a></span></span> <span class="locative-args">A</span></span></p>

<p>Return the transpose of <code>A</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AM-2A-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1671">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AM-2A-20FUNCTION-29" >M*</a></span></span> <span class="locative-args">A B &amp;KEY TRANSPOSE-A? TRANSPOSE-B?</span></span></p>

<p>Compute op(<code>A</code>) * op(<code>B</code>). Where op is either the identity or the
transpose operation depending on <code>TRANSPOSE-A?</code> and <code>TRANSPOSE-B?</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AMM-2A-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1683">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMM-2A-20FUNCTION-29" >MM*</a></span></span> <span class="locative-args">M &amp;REST ARGS</span></span></p>

<p>Convenience function to multiply several matrices. </p>

<p>(mm* a b c) =&gt; a * b * c</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AM--20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1710">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AM--20FUNCTION-29" >M-</a></span></span> <span class="locative-args">A B</span></span></p>

<p>Return <code>A</code> - <code>B</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AM-2B-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1716">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AM-2B-20FUNCTION-29" >M+</a></span></span> <span class="locative-args">A B</span></span></p>

<p>Return <code>A</code> + <code>B</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AINVERT-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1722">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AINVERT-20FUNCTION-29" >INVERT</a></span></span> <span class="locative-args">A</span></span></p>

<p>Return the inverse of <code>A</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ALOGDET-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1727">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ALOGDET-20FUNCTION-29" >LOGDET</a></span></span> <span class="locative-args">MAT</span></span></p>

<p>Logarithm of the determinant of <code>MAT</code>. Return -1, 1 or 0 (or
equivalent) to correct for the sign, as the second value.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-MAPPINGS-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-NON-DESTRUCTIVE-API-20MGL-PAX-3ASECTION-29" title="Non-destructive API">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-RANDOM-20MGL-PAX-3ASECTION-29" title="Random numbers">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-MAPPINGS-20MGL-PAX-3ASECTION-29" title="Mappings">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1736">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-MAPPINGS-20MGL-PAX-3ASECTION-29">14 Mappings</a></h2>

<p><a id='x-28MGL-MAT-3AMAP-CONCAT-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1741">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAP-CONCAT-20FUNCTION-29" >MAP-CONCAT</a></span></span> <span class="locative-args">FN MATS MAT &amp;KEY KEY PASS-RAW-P</span></span></p>

<p>Call <code>FN</code> with each element of <code>MATS</code> and <code>MAT</code> temporarily reshaped to
the dimensions of the current element of <code>MATS</code> and return <code>MAT</code>. For
the next element the displacement is increased so that there is no
overlap.</p>

<p><code>MATS</code> is keyed by <code>KEY</code> just like the CL sequence functions. Normally,
<code>FN</code> is called with the matrix returned by <code>KEY</code>. However, if
<code>PASS-RAW-P</code>, then the matrix returned by <code>KEY</code> is only used to
calculate dimensions and the element of <code>MATS</code> that was passed to <code>KEY</code>
is passed to <code>FN</code>, too.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">map-concat #'copy! <span class="paren2">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> <span class="paren3">(<span class="code">make-mat 2</span>)</span> <span class="paren3">(<span class="code">make-mat 4 <span class="keyword">:initial-element</span> 1</span>)</span></span>)</span>
            <span class="paren2">(<span class="code">make-mat '<span class="paren3">(<span class="code">2 3</span>)</span></span>)</span></span>)</span>
==&gt; #&lt;MAT 2x3 AB #2A<span class="paren1">(<span class="code"><span class="paren2">(<span class="code">0.0d0 0.0d0 1.0d0</span>)</span> <span class="paren2">(<span class="code">1.0d0 1.0d0 1.0d0</span>)</span></span>)</span>&gt;</span></code></pre></li>
</ul>

<p><a id='x-28MGL-MAT-3AMAP-DISPLACEMENTS-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1771">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAP-DISPLACEMENTS-20FUNCTION-29" >MAP-DISPLACEMENTS</a></span></span> <span class="locative-args">FN MAT DIMENSIONS &amp;KEY (DISPLACEMENT-START 0) DISPLACEMENT-STEP</span></span></p>

<p>Call <code>FN</code> with <code>MAT</code> reshaped to <code>DIMENSIONS</code>, first displaced by
<code>DISPLACEMENT-START</code> that's incremented by <code>DISPLACEMENT-STEP</code> each
iteration while there are enough elements left for <code>DIMENSIONS</code> at the
current displacement. Returns <code>MAT</code>.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">mat <span class="paren4">(<span class="code">make-mat 14 <span class="keyword">:initial-contents</span> '<span class="paren5">(<span class="code">-1 0 1 2 3
                                            4 5 6 7
                                            8 9 10 11 12</span>)</span></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">reshape-and-displace! mat '<span class="paren3">(<span class="code">4 3</span>)</span> 1</span>)</span>
  <span class="paren2">(<span class="code">map-displacements #'<a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm" class="symbol">print</a> mat 4</span>)</span></span>)</span>
..
.. #&lt;MAT 1+4+9 B #<span class="paren1">(<span class="code">0.0d0 1.0d0 2.0d0 3.0d0</span>)</span>&gt; 
.. #&lt;MAT 5+4+5 B #<span class="paren1">(<span class="code">4.0d0 5.0d0 6.0d0 7.0d0</span>)</span>&gt; 
.. #&lt;MAT 9+4+1 B #<span class="paren1">(<span class="code">8.0d0 9.0d0 10.0d0 11.0d0</span>)</span>&gt; </span></code></pre></li>
</ul>

<p><a id='x-28MGL-MAT-3AMAP-MATS-INTO-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1805">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAP-MATS-INTO-20FUNCTION-29" >MAP-MATS-INTO</a></span></span> <span class="locative-args">RESULT-MAT FN &amp;REST MATS</span></span></p>

<p>Like <code>CL:MAP-INTO</code> but for <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> objects. Destructively modifies
<code>RESULT-MAT</code> to contain the results of applying <code>FN</code> to each element in
the argument <code>MATS</code> in turn.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-RANDOM-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-MAPPINGS-20MGL-PAX-3ASECTION-29" title="Mappings">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-IO-20MGL-PAX-3ASECTION-29" title="I/O">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-RANDOM-20MGL-PAX-3ASECTION-29" title="Random numbers">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1838">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-RANDOM-20MGL-PAX-3ASECTION-29">15 Random numbers</a></h2>

<p>Unless noted these work efficiently with CUDA.</p>

<p><a id='x-28MGL-MAT-3ACOPY-RANDOM-STATE-20GENERIC-FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1846">[generic-function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACOPY-RANDOM-STATE-20GENERIC-FUNCTION-29" >COPY-RANDOM-STATE</a></span></span> <span class="locative-args">STATE</span></span></p>

<p>Return a copy of <code>STATE</code> be it a lisp or cuda random
state.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AUNIFORM-RANDOM-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1854">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AUNIFORM-RANDOM-21-20FUNCTION-29" >UNIFORM-RANDOM!</a></span></span> <span class="locative-args">MAT &amp;KEY (LIMIT 1)</span></span></p>

<p>Fill <code>MAT</code> with random numbers sampled uniformly from the [0,LIMIT)
interval of <code>MAT</code>'s type.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AGAUSSIAN-RANDOM-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1874">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AGAUSSIAN-RANDOM-21-20FUNCTION-29" >GAUSSIAN-RANDOM!</a></span></span> <span class="locative-args">MAT &amp;KEY (MEAN 0) (STDDEV 1)</span></span></p>

<p>Fill <code>MAT</code> with independent normally distributed random numbers with
<code>MEAN</code> and <code>STDDEV</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AMV-GAUSSIAN-RANDOM-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1914">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMV-GAUSSIAN-RANDOM-20FUNCTION-29" >MV-GAUSSIAN-RANDOM</a></span></span> <span class="locative-args">&amp;KEY MEANS COVARIANCES</span></span></p>

<p>Return a column vector of samples from the multivariate normal
distribution defined by <code>MEANS</code> (Nx1) and <code>COVARIANCES</code> (NxN). No CUDA
implementation.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AORTHOGONAL-RANDOM-21-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1935">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AORTHOGONAL-RANDOM-21-20FUNCTION-29" >ORTHOGONAL-RANDOM!</a></span></span> <span class="locative-args">M &amp;KEY (SCALE 1)</span></span></p>

<p>Fill the matrix <code>M</code> with random values in such a way that <code>M^T * M</code>
is the identity matrix (or something close if <code>M</code> is wide). Return <code>M</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-IO-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-RANDOM-20MGL-PAX-3ASECTION-29" title="Random numbers">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-DEBUGGING-20MGL-PAX-3ASECTION-29" title="Debugging">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-IO-20MGL-PAX-3ASECTION-29" title="I/O">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1952">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-IO-20MGL-PAX-3ASECTION-29">16 I/O</a></h2>

<p><a id='x-28MGL-MAT-3A-2AMAT-HEADERS-2A-20VARIABLE-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1957">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2AMAT-HEADERS-2A-20VARIABLE-29" >*MAT-HEADERS*</a></span></span> <span class="locative-args">T</span></span></p>

<p>If true, a header with <a href="#x-28MGL-MAT-3AMAT-CTYPE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-CTYPE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-CTYPE</code></a> and <a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> is written by
<a href="#x-28MGL-MAT-3AWRITE-MAT-20GENERIC-FUNCTION-29" title="(MGL-MAT:WRITE-MAT GENERIC-FUNCTION)"><code>WRITE-MAT</code></a> before the contents and <a href="#x-28MGL-MAT-3AREAD-MAT-20GENERIC-FUNCTION-29" title="(MGL-MAT:READ-MAT GENERIC-FUNCTION)"><code>READ-MAT</code></a> checks that these match
the matrix into which it is reading.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AWRITE-MAT-20GENERIC-FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1972">[generic-function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AWRITE-MAT-20GENERIC-FUNCTION-29" >WRITE-MAT</a></span></span> <span class="locative-args">MAT STREAM</span></span></p>

<p>Write <code>MAT</code> to binary <code>STREAM</code> in portable binary
format. Return <code>MAT</code>. Displacement and size are taken into account,
only visible elements are written. Also see <a href="#x-28MGL-MAT-3A-2AMAT-HEADERS-2A-20VARIABLE-29" title="(MGL-MAT:*MAT-HEADERS* VARIABLE)"><code>*MAT-HEADERS*</code></a>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AREAD-MAT-20GENERIC-FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L1989">[generic-function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AREAD-MAT-20GENERIC-FUNCTION-29" >READ-MAT</a></span></span> <span class="locative-args">MAT STREAM</span></span></p>

<p>Destructively modify the visible portion (with
regards to displacement and shape) of <code>MAT</code> by reading <a href="#x-28MGL-MAT-3AMAT-SIZE-20-28MGL-PAX-3AREADER-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:MAT-SIZE (MGL-PAX:READER MGL-MAT:MAT))"><code>MAT-SIZE</code></a> number
of elements from binary <code>STREAM</code>. Return <code>MAT</code>. Also see
<a href="#x-28MGL-MAT-3A-2AMAT-HEADERS-2A-20VARIABLE-29" title="(MGL-MAT:*MAT-HEADERS* VARIABLE)"><code>*MAT-HEADERS*</code></a>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-DEBUGGING-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-IO-20MGL-PAX-3ASECTION-29" title="I/O">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-FACET-API-20MGL-PAX-3ASECTION-29" title="Facet API">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-DEBUGGING-20MGL-PAX-3ASECTION-29" title="Debugging">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L2029">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-DEBUGGING-20MGL-PAX-3ASECTION-29">17 Debugging</a></h2>

<p>The largest class of bugs has to do with synchronization of facets
being broken. This is almost always caused by an operation that
mispecifies the <a href="cube-manual.html#x-28MGL-CUBE-3ADIRECTION-20TYPE-29" title="(MGL-CUBE:DIRECTION TYPE)"><code>DIRECTION</code></a> argument of <a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACET-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACET MGL-PAX:MACRO)"><code>WITH-FACET</code></a>. For example, the
matrix argument of <a href="#x-28MGL-MAT-3ASCAL-21-20FUNCTION-29" title="(MGL-MAT:SCAL! FUNCTION)"><code>SCAL!</code></a> should be accessed with direciton <code>:IO</code>. But
if it's <code>:INPUT</code> instead, then subsequent access to the <a href="#x-28ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(ARRAY MGL-CUBE:FACET-NAME)"><code>ARRAY</code></a> facet
will not see the changes made by <a href="#x-28MGL-MAT-3AAXPY-21-20FUNCTION-29" title="(MGL-MAT:AXPY! FUNCTION)"><code>AXPY!</code></a>, and if it's <code>:OUTPUT</code>, then
any changes made to the <code>ARRAY</code> facet since the last update of the
<a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a> facet will not be copied and from the wrong input <code>SCAL!</code>
will compute the wrong result.</p>

<p>Using the SLIME inspector or trying to access the
<a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a> facet from threads other than the one in
which the corresponding CUDA context was initialized will fail. For
now, the easy way out is to debug the code with CUDA disabled (see
<a href="#x-28MGL-MAT-3A-2ACUDA-ENABLED-2A-20VARIABLE-29" title="(MGL-MAT:*CUDA-ENABLED* VARIABLE)"><code>*CUDA-ENABLED*</code></a>).</p>

<p>Another thing that tends to come up is figuring out where memory is
used.</p>

<p><a id='x-28MGL-MAT-3AMAT-ROOM-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L2051">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AMAT-ROOM-20FUNCTION-29" >MAT-ROOM</a></span></span> <span class="locative-args">&amp;KEY (STREAM <code>*STANDARD-OUTPUT*</code>) (VERBOSE <code>T</code>)</span></span></p>

<p>Calls <a href="#x-28MGL-MAT-3AFOREIGN-ROOM-20FUNCTION-29" title="(MGL-MAT:FOREIGN-ROOM FUNCTION)"><code>FOREIGN-ROOM</code></a> and <a href="#x-28MGL-MAT-3ACUDA-ROOM-20FUNCTION-29" title="(MGL-MAT:CUDA-ROOM FUNCTION)"><code>CUDA-ROOM</code></a>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AWITH-MAT-COUNTERS-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L2058">[macro]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AWITH-MAT-COUNTERS-20MGL-PAX-3AMACRO-29" >WITH-MAT-COUNTERS</a></span></span> <span class="locative-args">(&amp;KEY COUNT N-BYTES) &amp;BODY BODY</span></span></p>

<p>Count all <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> allocations and also the number of bytes they may
require. <em>May require</em> here really means an upper bound,
because <code>(MAKE-MAT (EXPT 2 60))</code> doesn't actually uses memory until
one of its facets is accessed (don't simply evaluate it though,
printing the result will access the <a href="#x-28ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(ARRAY MGL-CUBE:FACET-NAME)"><code>ARRAY</code></a> facet if <a href="#x-28MGL-MAT-3A-2APRINT-MAT-2A-20VARIABLE-29" title="(MGL-MAT:*PRINT-MAT* VARIABLE)"><code>*PRINT-MAT*</code></a>).
Also, while facets today all require the same number of bytes, this
may change in the future. This is a debugging tool, don't use it in
production.</p>

<pre><code>(with-mat-counters (:count count :n-bytes n-bytes)
  (assert (= count 0))
  (assert (= n-bytes 0))
  (make-mat '(2 3) :ctype :double)
  (assert (= count 1))
  (assert (= n-bytes (* 2 3 8)))
  (with-mat-counters (:n-bytes n-bytes-1 :count count-1)
    (make-mat '7 :ctype :float)
    (assert (= count-1 1))
    (assert (= n-bytes-1 (* 7 4))))
  (assert (= n-bytes (+ (* 2 3 8) (* 7 4))))
  (assert (= count 2)))
</code></pre></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-FACET-API-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-DEBUGGING-20MGL-PAX-3ASECTION-29" title="Debugging">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-FACETS-20MGL-PAX-3ASECTION-29" title="Facets">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-FACET-API-20MGL-PAX-3ASECTION-29" title="Facet API">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L2097">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-FACET-API-20MGL-PAX-3ASECTION-29">18 Facet API</a></h2>

<p><a id='x-28MGL-MAT-3A-40MAT-FACETS-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-FACET-API-20MGL-PAX-3ASECTION-29" title="Facet API">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-FACET-API-20MGL-PAX-3ASECTION-29" title="Facet API">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-FOREIGN-20MGL-PAX-3ASECTION-29" title="Foreign arrays">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-FACETS-20MGL-PAX-3ASECTION-29" title="Facets">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L2103">&#955;</a></span></span></p>

<h3><a href="#x-28MGL-MAT-3A-40MAT-FACETS-20MGL-PAX-3ASECTION-29">18.1 Facets</a></h3>

<p>A <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> is a <a href="cube-manual.html#x-28MGL-CUBE-3ACUBE-20CLASS-29" title="(MGL-CUBE:CUBE CLASS)"><code>CUBE</code></a> (see <a href="cube-manual.html#x-28MGL-CUBE-3A-40CUBE-MANUAL-20MGL-PAX-3ASECTION-29" title="Cube Manual">Cube Manual</a>) whose facets are different
representations of numeric arrays. These facets can be accessed with
<a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACETS-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACETS MGL-PAX:MACRO)"><code>WITH-FACETS</code></a> with one of the following <a href="cube-manual.html#x-28MGL-CUBE-3AFACET-NAME-20MGL-PAX-3ALOCATIVE-29" title="(MGL-CUBE:FACET-NAME MGL-PAX:LOCATIVE)"><code>FACET-NAME</code></a>
locatives:</p>

<p><a id='x-28MGL-MAT-3ABACKING-ARRAY-20MGL-CUBE-3AFACET-NAME-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L2174">[facet-name]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ABACKING-ARRAY-20MGL-CUBE-3AFACET-NAME-29" >BACKING-ARRAY</a></span></span></span></p>

<p>The corresponding facet's value is a one dimensional lisp array or
a static vector that also looks exactly like a lisp array but is
allocated in foreign memory. See <a href="#x-28MGL-MAT-3A-2AFOREIGN-ARRAY-STRATEGY-2A-20-28VARIABLE-20-22-see-20below--22-29-29" title="(MGL-MAT:*FOREIGN-ARRAY-STRATEGY* (VARIABLE \&quot;-see below-\&quot;))"><code>*FOREIGN-ARRAY-STRATEGY*</code></a>.</p></li>
</ul>

<p><a id='x-28ARRAY-20MGL-CUBE-3AFACET-NAME-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L2179">[facet-name]</a></span> <span class="reference-object"><a href="#x-28ARRAY-20MGL-CUBE-3AFACET-NAME-29" >ARRAY</a></span></span></span></p>

<p>Same as <a href="#x-28MGL-MAT-3ABACKING-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:BACKING-ARRAY MGL-CUBE:FACET-NAME)"><code>BACKING-ARRAY</code></a> if the matrix is one-dimensional, all
elements are visible (see <a href="#x-28MGL-MAT-3A-40MAT-SHAPING-20MGL-PAX-3ASECTION-29" title="Shaping">Shaping</a>), else it's a lisp array
displaced to the backing array.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AFOREIGN-ARRAY-20MGL-CUBE-3AFACET-NAME-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L2184">[facet-name]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20MGL-CUBE-3AFACET-NAME-29" >FOREIGN-ARRAY</a></span></span></span></p>

<p>The facet's value is a <a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20CLASS-29" title="(MGL-MAT:FOREIGN-ARRAY CLASS)"><code>FOREIGN-ARRAY</code></a> which is an
<code>OFFSET-POINTER</code> wrapping a <code>CFFI</code> pointer. See
<a href="#x-28MGL-MAT-3A-2AFOREIGN-ARRAY-STRATEGY-2A-20-28VARIABLE-20-22-see-20below--22-29-29" title="(MGL-MAT:*FOREIGN-ARRAY-STRATEGY* (VARIABLE \&quot;-see below-\&quot;))"><code>*FOREIGN-ARRAY-STRATEGY*</code></a>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ACUDA-HOST-ARRAY-20MGL-CUBE-3AFACET-NAME-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L2189">[facet-name]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACUDA-HOST-ARRAY-20MGL-CUBE-3AFACET-NAME-29" >CUDA-HOST-ARRAY</a></span></span></span></p>

<p>This facet's value is a basically the same as that of
<a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:FOREIGN-ARRAY MGL-CUBE:FACET-NAME)"><code>FOREIGN-ARRAY</code></a>. In fact, they share storage. The
difference is that accessing <a href="#x-28MGL-MAT-3ACUDA-HOST-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-HOST-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-HOST-ARRAY</code></a> ensures
that the foreign memory region is page-locked and registered with
the CUDA Driver API function cuMemHostRegister(). Copying between
GPU memory (<a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a>) and registered memory is
significantly faster than with non-registered memory and also allows
overlapping copying with computation. See
<a href="#x-28MGL-MAT-3AWITH-SYNCING-CUDA-FACETS-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-SYNCING-CUDA-FACETS MGL-PAX:MACRO)"><code>WITH-SYNCING-CUDA-FACETS</code></a>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L2200">[facet-name]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" >CUDA-ARRAY</a></span></span></span></p>

<p>The facet's value is a [CUDA-ARRAY] which is an
<code>OFFSET-POINTER</code> wrapping a <code>CL-CUDA.DRIVER-API:CU-DEVICE-PTR</code>,
allocated with <code>CL-CUDA.DRIVER-API:CU-MEM-ALLOC</code> and freed
automatically.</p></li>
</ul>

<p>Facets bound by with <a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACETS-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACETS MGL-PAX:MACRO)"><code>WITH-FACETS</code></a> are to be treated as dynamic
extent: it is not allowed to keep a reference to them beyond the
dynamic scope of <code>WITH-FACETS</code>.</p>

<p>For example, to implement the <a href="#x-28MGL-MAT-3AFILL-21-20FUNCTION-29" title="(MGL-MAT:FILL! FUNCTION)"><code>FILL!</code></a> operation using only the
<a href="#x-28MGL-MAT-3ABACKING-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:BACKING-ARRAY MGL-CUBE:FACET-NAME)"><code>BACKING-ARRAY</code></a>, one could do this:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">displacement <span class="paren4">(<span class="code">mat-displacement x</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">size <span class="paren4">(<span class="code">mat-size x</span>)</span></span>)</span></span>)</span>
 <span class="paren2">(<span class="code"><i><span class="symbol">with-facets</span></i> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">x* <span class="paren5">(<span class="code">x 'backing-array <span class="keyword">:direction</span> <span class="keyword">:output</span></span>)</span></span>)</span></span>)</span>
   <span class="paren3">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_fill.htm" class="symbol">fill</a> x* 1 <span class="keyword">:start</span> displacement <span class="keyword">:end</span> <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> displacement size</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p><a href="cube-manual.html#x-28MGL-CUBE-3ADIRECTION-20TYPE-29" title="(MGL-CUBE:DIRECTION TYPE)"><code>DIRECTION</code></a> is <code>:OUTPUT</code> because we clobber all values in <code>X</code>. Armed
with this knowledge about the direction, <code>WITH-FACETS</code> will not copy
data from another facet if the backing array is not up-to-date.</p>

<p>To transpose a 2d matrix with the <a href="#x-28ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(ARRAY MGL-CUBE:FACET-NAME)"><code>ARRAY</code></a> facet:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_destru.htm" class="symbol">destructuring-bind</a> <span class="paren2">(<span class="code">n-rows n-columns</span>)</span> <span class="paren2">(<span class="code">mat-dimensions x</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">with-facets</span></i> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">x* <span class="paren5">(<span class="code">x '<a href="http://www.lispworks.com/reference/HyperSpec/Body/t_array.htm" class="symbol">array</a> <span class="keyword">:direction</span> <span class="keyword">:io</span></span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_dotime.htm" class="symbol">dotimes</a> <span class="paren4">(<span class="code">row n-rows</span>)</span>
      <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_dotime.htm" class="symbol">dotimes</a> <span class="paren5">(<span class="code">column n-columns</span>)</span>
        <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren6">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_aref.htm" class="symbol">aref</a> x* row column</span>)</span> <span class="paren6">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_aref.htm" class="symbol">aref</a> x* column row</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>Note that <code>DIRECTION</code> is <code>:IO</code>, because we need the data in this facet
to be up-to-date (that's the input part) and we are invalidating all
other facets by changing values (that's the output part).</p>

<p>To sum the values of a matrix using the <a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:FOREIGN-ARRAY MGL-CUBE:FACET-NAME)"><code>FOREIGN-ARRAY</code></a>
facet:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">sum 0</span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">with-facets</span></i> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">x* <span class="paren5">(<span class="code">x 'foreign-array <span class="keyword">:direction</span> <span class="keyword">:input</span></span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">pointer <span class="paren6">(<span class="code">offset-pointer x*</span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for index below <span class="paren5">(<span class="code">mat-size x</span>)</span>
            <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_incf_.htm" class="symbol">incf</a> sum <span class="paren6">(<span class="code">cffi:mem-aref pointer <span class="paren1">(<span class="code">mat-ctype x</span>)</span> index</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
  sum</span>)</span></span></code></pre>

<p>See <code>DIRECTION</code> for a complete description of <code>:INPUT</code>, <code>:OUTPUT</code> and <code>:IO</code>.
For <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> objects, that needs to be refined. If a <code>MAT</code> is reshaped
and/or displaced in a way that not all elements are visible then
those elements are always kept intact and copied around. This is
accomplished by turning <code>:OUTPUT</code> into <code>:IO</code> automatically on such <code>MATs</code>.</p>

<p>We have finished our introduction to the various facets. It must be
said though that one can do anything without ever accessing a facet
directly or even being aware of them as most operations on <code>MAT</code>s
take care of choosing the most appropriate facet behind the scenes.
In particular, most operations automatically use CUDA, if available
and initialized. See <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a> for detail.</p>

<p><a id='x-28MGL-MAT-3A-40MAT-FOREIGN-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-FACETS-20MGL-PAX-3ASECTION-29" title="Facets">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-FACET-API-20MGL-PAX-3ASECTION-29" title="Facet API">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-20MGL-PAX-3ASECTION-29" title="CUDA">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-FOREIGN-20MGL-PAX-3ASECTION-29" title="Foreign arrays">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/foreign.lisp#L3">&#955;</a></span></span></p>

<h3><a href="#x-28MGL-MAT-3A-40MAT-FOREIGN-20MGL-PAX-3ASECTION-29">18.2 Foreign arrays</a></h3>

<p>One facet of <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> objects is <a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:FOREIGN-ARRAY MGL-CUBE:FACET-NAME)"><code>FOREIGN-ARRAY</code></a> which is
backed by a memory area that can be a pinned lisp array or is
allocated in foreign memory depending on <a href="#x-28MGL-MAT-3A-2AFOREIGN-ARRAY-STRATEGY-2A-20-28VARIABLE-20-22-see-20below--22-29-29" title="(MGL-MAT:*FOREIGN-ARRAY-STRATEGY* (VARIABLE \&quot;-see below-\&quot;))"><code>*FOREIGN-ARRAY-STRATEGY*</code></a>.</p>

<p><a id='x-28MGL-MAT-3AFOREIGN-ARRAY-20CLASS-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/foreign.lisp#L51">[class]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20CLASS-29" >FOREIGN-ARRAY</a></span></span></span></p>

<p><a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20CLASS-29" title="(MGL-MAT:FOREIGN-ARRAY CLASS)"><code>FOREIGN-ARRAY</code></a> wraps a foreign pointer (in
the sense of <code>CFFI:POINTERP</code>). That is, both <code>OFFSET-POINTER</code> and
<code>BASE-POINTER</code> return a foreign pointer. There are no other public
operations that work with <a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-20CLASS-29" title="(MGL-MAT:FOREIGN-ARRAY CLASS)"><code>FOREIGN-ARRAY</code></a> objects, their sole
purpose is represent facets of <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> objects.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2AFOREIGN-ARRAY-STRATEGY-2A-20-28VARIABLE-20-22-see-20below--22-29-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/foreign.lisp#L107">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2AFOREIGN-ARRAY-STRATEGY-2A-20-28VARIABLE-20-22-see-20below--22-29-29" >*FOREIGN-ARRAY-STRATEGY*</a></span></span> <span class="locative-args">&quot;-see below-&quot;</span></span></p>

<p>One of <code>:PINNED</code>, <code>:STATIC</code> and <code>:CUDA-HOST</code> (see type
<a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-STRATEGY-20TYPE-29" title="(MGL-MAT:FOREIGN-ARRAY-STRATEGY TYPE)"><code>FOREIGN-ARRAY-STRATEGY</code></a>). This variable controls how foreign arrays
are handled and it can be changed at any time.</p>

<p>If it's <code>:PINNED</code> (only supported if (<a href="#x-28MGL-MAT-3APINNING-SUPPORTED-P-20FUNCTION-29" title="(MGL-MAT:PINNING-SUPPORTED-P FUNCTION)"><code>PINNING-SUPPORTED-P</code></a>), then no
separate storage is allocated for the foreign array. Instead, it
aliases the lisp array (via the <a href="#x-28MGL-MAT-3ABACKING-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:BACKING-ARRAY MGL-CUBE:FACET-NAME)"><code>BACKING-ARRAY</code></a> facet).</p>

<p>If it's <code>:STATIC</code>, then the lisp backing arrays are allocated
statically via the static-vectors library. On some implementations,
explicit freeing of static vectors is necessary, this is taken care
of by finalizers or can be controlled with <a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACET-BARRIER-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACET-BARRIER MGL-PAX:MACRO)"><code>WITH-FACET-BARRIER</code></a>.
<a href="cube-manual.html#x-28MGL-CUBE-3ADESTROY-CUBE-20FUNCTION-29" title="(MGL-CUBE:DESTROY-CUBE FUNCTION)"><code>DESTROY-CUBE</code></a> and <a href="cube-manual.html#x-28MGL-CUBE-3ADESTROY-FACET-20FUNCTION-29" title="(MGL-CUBE:DESTROY-FACET FUNCTION)"><code>DESTROY-FACET</code></a> may also be of help.</p>

<p><code>:CUDA-HOST</code> is the same as <code>:STATIC</code>, but any copies to/from the
GPU (i.e. the <a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a> facet) will be done via the
<a href="#x-28MGL-MAT-3ACUDA-HOST-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-HOST-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-HOST-ARRAY</code></a> facet whose memory pages will also be
locked and registered with <code>cuMemHostRegister</code> which allows quicker
and asynchronous copying to and from CUDA land.</p>

<p>The default is <code>:PINNED</code> if available, because it's the most
efficient. If pinning is not available, then it's <code>:STATIC</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AFOREIGN-ARRAY-STRATEGY-20TYPE-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/foreign.lisp#L94">[type]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AFOREIGN-ARRAY-STRATEGY-20TYPE-29" >FOREIGN-ARRAY-STRATEGY</a></span></span></span></p>

<p>One of <code>:PINNED</code>, <code>:STATIC</code> and <code>:CUDA-HOST</code>. See
<a href="#x-28MGL-MAT-3A-2AFOREIGN-ARRAY-STRATEGY-2A-20-28VARIABLE-20-22-see-20below--22-29-29" title="(MGL-MAT:*FOREIGN-ARRAY-STRATEGY* (VARIABLE \&quot;-see below-\&quot;))"><code>*FOREIGN-ARRAY-STRATEGY*</code></a> for their semantics.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3APINNING-SUPPORTED-P-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/foreign.lisp#L99">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3APINNING-SUPPORTED-P-20FUNCTION-29" >PINNING-SUPPORTED-P</a></span></span> <span class="locative-args"></span></span></p>

<p>Return true iff the lisp implementation efficiently supports
pinning lisp arrays. Pinning ensures that the garbage collector
doesn't move the array in memory. Currently this is only supported on
SBCL gencgc platforms.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AFOREIGN-ROOM-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/foreign.lisp#L24">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AFOREIGN-ROOM-20FUNCTION-29" >FOREIGN-ROOM</a></span></span> <span class="locative-args">&amp;KEY (STREAM <code>*STANDARD-OUTPUT*</code>) (VERBOSE <code>T</code>)</span></span></p>

<p>Print a summary of foreign memory usage to <code>STREAM</code>. If <code>VERBOSE</code>, make
the output human easily readable, else try to present it in a very
concise way. Sample output with <code>VERBOSE</code>:</p>

<pre><code><span class="code">Foreign memory usage:
foreign arrays: 450 <span class="paren1">(<span class="code">used bytes: 3,386,295,808</span>)</span></span></code></pre>

<p>The same data presented with <code>VERBOSE</code> false:</p>

<pre><code><span class="code">f: 450 <span class="paren1">(<span class="code">3,386,295,808</span>)</span></span></code></pre></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-CUDA-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-FOREIGN-20MGL-PAX-3ASECTION-29" title="Foreign arrays">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-FACET-API-20MGL-PAX-3ASECTION-29" title="Facet API">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-MEMORY-MANAGEMENT-20MGL-PAX-3ASECTION-29" title="CUDA Memory Management">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-20MGL-PAX-3ASECTION-29" title="CUDA">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-early.lisp#L3">&#955;</a></span></span></p>

<h3><a href="#x-28MGL-MAT-3A-40MAT-CUDA-20MGL-PAX-3ASECTION-29">18.3 CUDA</a></h3>

<p><a id='x-28MGL-MAT-3ACUDA-AVAILABLE-P-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-late.lisp#L107">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACUDA-AVAILABLE-P-20FUNCTION-29" >CUDA-AVAILABLE-P</a></span></span> <span class="locative-args">&amp;KEY (DEVICE-ID 0)</span></span></p>

<p>Check that a cuda context is already in initialized in the current
thread or a device with <code>DEVICE-ID</code> is available.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-late.lisp#L116">[macro]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" >WITH-CUDA*</a></span></span> <span class="locative-args">(&amp;KEY (ENABLED '<a href="#x-28MGL-MAT-3A-2ACUDA-ENABLED-2A-20VARIABLE-29" title="(MGL-MAT:*CUDA-ENABLED* VARIABLE)"><code>*CUDA-ENABLED*</code></a>) (DEVICE-ID '<a href="#x-28MGL-MAT-3A-2ACUDA-DEFAULT-DEVICE-ID-2A-20VARIABLE-29" title="(MGL-MAT:*CUDA-DEFAULT-DEVICE-ID* VARIABLE)"><code>*CUDA-DEFAULT-DEVICE-ID*</code></a>) (RANDOM-SEED '<a href="#x-28MGL-MAT-3A-2ACUDA-DEFAULT-RANDOM-SEED-2A-20VARIABLE-29" title="(MGL-MAT:*CUDA-DEFAULT-RANDOM-SEED* VARIABLE)"><code>*CUDA-DEFAULT-RANDOM-SEED*</code></a>) (N-RANDOM-STATES '<a href="#x-28MGL-MAT-3A-2ACUDA-DEFAULT-N-RANDOM-STATES-2A-20VARIABLE-29" title="(MGL-MAT:*CUDA-DEFAULT-N-RANDOM-STATES* VARIABLE)"><code>*CUDA-DEFAULT-N-RANDOM-STATES*</code></a>) N-POOL-BYTES) &amp;BODY BODY</span></span></p>

<p>Initializes CUDA with with all bells and whistles before <code>BODY</code> and
deinitializes it after. Simply wrapping <code>WITH-CUDA*</code> around a piece
code is enough to make use of the first available CUDA device or
fall back on blas and lisp kernels if there is none.</p>

<p>If CUDA is already initialized, then it sets up a facet barrier
which destroys <a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a> and <a href="#x-28MGL-MAT-3ACUDA-HOST-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-HOST-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-HOST-ARRAY</code></a> facets after ensuring
that the <a href="#x-28ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(ARRAY MGL-CUBE:FACET-NAME)"><code>ARRAY</code></a> facet is up-to-date.</p>

<p>Else, if CUDA is available and <code>ENABLED</code>, then in addition to the
facet barrier, a CUDA context is set up, <a href="#x-28MGL-MAT-3A-2AN-MEMCPY-HOST-TO-DEVICE-2A-20VARIABLE-29" title="(MGL-MAT:*N-MEMCPY-HOST-TO-DEVICE* VARIABLE)"><code>*N-MEMCPY-HOST-TO-DEVICE*</code></a>,
<a href="#x-28MGL-MAT-3A-2AN-MEMCPY-DEVICE-TO-HOST-2A-20VARIABLE-29" title="(MGL-MAT:*N-MEMCPY-DEVICE-TO-HOST* VARIABLE)"><code>*N-MEMCPY-DEVICE-TO-HOST*</code></a> are bound to zero, a cublas handle
created, and <a href="#x-28MGL-MAT-3A-2ACURAND-STATE-2A-20VARIABLE-29" title="(MGL-MAT:*CURAND-STATE* VARIABLE)"><code>*CURAND-STATE*</code></a> is bound to a <a href="#x-28MGL-MAT-3ACURAND-XORWOW-STATE-20CLASS-29" title="(MGL-MAT:CURAND-XORWOW-STATE CLASS)"><code>CURAND-XORWOW-STATE</code></a> with
<code>N-RANDOM-STATES</code>, seeded with <code>RANDOM-SEED</code>, and allocation of device
memory is limited to <code>N-POOL-BYTES</code> (<code>NIL</code> means no limit, see
<a href="#x-28MGL-MAT-3A-40MAT-CUDA-MEMORY-MANAGEMENT-20MGL-PAX-3ASECTION-29" title="CUDA Memory Management">CUDA Memory Management</a>).</p>

<p>Else - that is, if CUDA is not available, <code>BODY</code> is simply executed.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ACALL-WITH-CUDA-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-late.lisp#L74">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACALL-WITH-CUDA-20FUNCTION-29" >CALL-WITH-CUDA</a></span></span> <span class="locative-args">FN &amp;KEY ((:ENABLED *CUDA-ENABLED*) *CUDA-ENABLED*) (DEVICE-ID <a href="#x-28MGL-MAT-3A-2ACUDA-DEFAULT-DEVICE-ID-2A-20VARIABLE-29" title="(MGL-MAT:*CUDA-DEFAULT-DEVICE-ID* VARIABLE)"><code>*CUDA-DEFAULT-DEVICE-ID*</code></a>) (RANDOM-SEED <a href="#x-28MGL-MAT-3A-2ACUDA-DEFAULT-RANDOM-SEED-2A-20VARIABLE-29" title="(MGL-MAT:*CUDA-DEFAULT-RANDOM-SEED* VARIABLE)"><code>*CUDA-DEFAULT-RANDOM-SEED*</code></a>) (N-RANDOM-STATES <a href="#x-28MGL-MAT-3A-2ACUDA-DEFAULT-N-RANDOM-STATES-2A-20VARIABLE-29" title="(MGL-MAT:*CUDA-DEFAULT-N-RANDOM-STATES* VARIABLE)"><code>*CUDA-DEFAULT-N-RANDOM-STATES*</code></a>) N-POOL-BYTES</span></span></p>

<p>Like <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a>, but takes a no argument function instead of the
macro's <code>BODY</code>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ACUDA-ENABLED-2A-20VARIABLE-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-early.lisp#L39">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ACUDA-ENABLED-2A-20VARIABLE-29" >*CUDA-ENABLED*</a></span></span> <span class="locative-args">T</span></span></p>

<p>Set or bind this to false to disable all use of cuda. If this is
done from within <code>WITH-CUDA</code><em>, then cuda becomes temporarily disabled.
If this is done from outside <code>WITH-CUDA</code></em>, then it changes the default
values of the <code>ENABLED</code> argument of any future <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a>s which
turns off cuda initialization entirely.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ACUDA-ENABLED-20-28MGL-PAX-3AACCESSOR-20MGL-MAT-3AMAT-29-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L211">[accessor]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACUDA-ENABLED-20-28MGL-PAX-3AACCESSOR-20MGL-MAT-3AMAT-29-29" >CUDA-ENABLED</a></span></span> <span class="locative-args">MAT</span> <span class="locative-args">(:CUDA-ENABLED = <a href="#x-28MGL-MAT-3A-2ADEFAULT-MAT-CUDA-ENABLED-2A-20VARIABLE-29" title="(MGL-MAT:*DEFAULT-MAT-CUDA-ENABLED* VARIABLE)"><code>*DEFAULT-MAT-CUDA-ENABLED*</code></a>)</span></span></p>

<p>The control provided by <a href="#x-28MGL-MAT-3A-2ACUDA-ENABLED-2A-20VARIABLE-29" title="(MGL-MAT:*CUDA-ENABLED* VARIABLE)"><code>*CUDA-ENABLED*</code></a> can be too
coarse. This flag provides a per-object mechanism to turn cuda
off. If it is set to <code>NIL</code>, then any operation that pays attention
to this flag will not create or access the <a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a> facet.
Implementationally speaking, this is easily accomplished by using
<a href="#x-28MGL-MAT-3AUSE-CUDA-P-20FUNCTION-29" title="(MGL-MAT:USE-CUDA-P FUNCTION)"><code>USE-CUDA-P</code></a>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ADEFAULT-MAT-CUDA-ENABLED-2A-20VARIABLE-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L193">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ADEFAULT-MAT-CUDA-ENABLED-2A-20VARIABLE-29" >*DEFAULT-MAT-CUDA-ENABLED*</a></span></span> <span class="locative-args">T</span></span></p>

<p>The default for <a href="#x-28MGL-MAT-3ACUDA-ENABLED-20-28MGL-PAX-3AACCESSOR-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:CUDA-ENABLED (MGL-PAX:ACCESSOR MGL-MAT:MAT))"><code>CUDA-ENABLED</code></a>.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2AN-MEMCPY-HOST-TO-DEVICE-2A-20VARIABLE-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-late.lisp#L12">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2AN-MEMCPY-HOST-TO-DEVICE-2A-20VARIABLE-29" >*N-MEMCPY-HOST-TO-DEVICE*</a></span></span> <span class="locative-args">0</span></span></p>

<p>Incremented each time a host to device copy is performed. Bound to
0 by <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a>. Useful for tracking down performance problems.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2AN-MEMCPY-DEVICE-TO-HOST-2A-20VARIABLE-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-late.lisp#L16">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2AN-MEMCPY-DEVICE-TO-HOST-2A-20VARIABLE-29" >*N-MEMCPY-DEVICE-TO-HOST*</a></span></span> <span class="locative-args">0</span></span></p>

<p>Incremented each time a device to host copy is performed. Bound to
0 by <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a>. Useful for tracking down performance problems.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ACUDA-DEFAULT-DEVICE-ID-2A-20VARIABLE-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-late.lisp#L3">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ACUDA-DEFAULT-DEVICE-ID-2A-20VARIABLE-29" >*CUDA-DEFAULT-DEVICE-ID*</a></span></span> <span class="locative-args">0</span></span></p>

<p>The default value of <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a>'s <code>:DEVICE-ID</code> argument.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ACUDA-DEFAULT-RANDOM-SEED-2A-20VARIABLE-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-late.lisp#L6">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ACUDA-DEFAULT-RANDOM-SEED-2A-20VARIABLE-29" >*CUDA-DEFAULT-RANDOM-SEED*</a></span></span> <span class="locative-args">1234</span></span></p>

<p>The default value of <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a>'s <code>:RANDOM-SEED</code> argument.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ACUDA-DEFAULT-N-RANDOM-STATES-2A-20VARIABLE-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-late.lisp#L9">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ACUDA-DEFAULT-N-RANDOM-STATES-2A-20VARIABLE-29" >*CUDA-DEFAULT-N-RANDOM-STATES*</a></span></span> <span class="locative-args">4096</span></span></p>

<p>The default value of <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a>'s <code>:N-RANDOM-STATES</code> argument.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-CUDA-MEMORY-MANAGEMENT-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-20MGL-PAX-3ASECTION-29" title="CUDA">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-20MGL-PAX-3ASECTION-29" title="CUDA">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-EXTENSIONS-20MGL-PAX-3ASECTION-29" title="Writing Extensions">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-MEMORY-MANAGEMENT-20MGL-PAX-3ASECTION-29" title="CUDA Memory Management">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-early.lisp#L182">&#955;</a></span></span></p>

<h4><a href="#x-28MGL-MAT-3A-40MAT-CUDA-MEMORY-MANAGEMENT-20MGL-PAX-3ASECTION-29">18.3.1 CUDA Memory Management</a></h4>

<p>The GPU (called <em>device</em> in CUDA terminology) has its own memory
and it can only perform computation on data in this <em>device memory</em>
so there is some copying involved to and from main memory. Efficient
algorithms often allocate device memory up front and minimize the
amount of copying that has to be done by computing as much as
possible on the GPU.</p>

<p>MGL-MAT reduces the cost of device of memory allocations by
maintaining a cache of currently unused allocations from which it
first tries to satisfy allocation requests. The total size of all
the allocated device memory regions (be they in use or currently
unused but cached) is never more than <code>N-POOL-BYTES</code> as specified in
<a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a>. <code>N-POOL-BYTES</code> being <code>NIL</code> means no limit.</p>

<p><a id='x-28MGL-MAT-3ACUDA-OUT-OF-MEMORY-20CONDITION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-early.lisp#L445">[condition]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACUDA-OUT-OF-MEMORY-20CONDITION-29" >CUDA-OUT-OF-MEMORY</a></span></span> <span class="locative-args">STORAGE-CONDITION</span></span></p>

<p>If an allocation request cannot be
satisfied (either because of <code>N-POOL-BYTES</code> or physical device memory
limits being reached), then <code>CUDA-OUT-OF-MEMORY</code> is signalled.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ACUDA-ROOM-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-late.lisp#L41">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACUDA-ROOM-20FUNCTION-29" >CUDA-ROOM</a></span></span> <span class="locative-args">&amp;KEY (STREAM <code>*STANDARD-OUTPUT*</code>) (VERBOSE <code>T</code>)</span></span></p>

<p>When CUDA is in use (see <a href="#x-28MGL-MAT-3AUSE-CUDA-P-20FUNCTION-29" title="(MGL-MAT:USE-CUDA-P FUNCTION)"><code>USE-CUDA-P</code></a>), print a summary of memory
usage in the current CUDA context to <code>STREAM</code>. If <code>VERBOSE</code>, make the
output human easily readable, else try to present it in a very
concise way. Sample output with <code>VERBOSE</code>:</p>

<pre><code><span class="code">CUDA memory usage:
device arrays: 450 <span class="paren1">(<span class="code">used bytes: 3,386,295,808, pooled bytes: 1,816,657,920</span>)</span>
host arrays: 14640 <span class="paren1">(<span class="code">used bytes: 17,380,147,200</span>)</span>
host-&gt;device copies: 154,102,488, device-&gt;host copies: 117,136,434</span></code></pre>

<p>The same data presented with <code>VERBOSE</code> false:</p>

<pre><code><span class="code">d: 450 <span class="paren1">(<span class="code">3,386,295,808 <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> 1,816,657,920</span>)</span>, h: 14640 <span class="paren1">(<span class="code">17,380,147,200</span>)</span>
h-&gt;d: 154,102,488, d-&gt;h: 117,136,434</span></code></pre></li>
</ul>

<p>That's it about reducing the cost allocations. The other important
performance consideration, minimizing the amount copying done, is
very hard to do if the data doesn't fit in device memory which is
often a very limited resource. In this case the next best thing is
to do the copying concurrently with computation.</p>

<p><a id='x-28MGL-MAT-3AWITH-SYNCING-CUDA-FACETS-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-early.lisp#L211">[macro]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AWITH-SYNCING-CUDA-FACETS-20MGL-PAX-3AMACRO-29" >WITH-SYNCING-CUDA-FACETS</a></span></span> <span class="locative-args">(MATS-TO-CUDA MATS-TO-CUDA-HOST &amp;KEY (SAFEP '<a href="#x-28MGL-MAT-3A-2ASYNCING-CUDA-FACETS-SAFE-P-2A-20VARIABLE-29" title="(MGL-MAT:*SYNCING-CUDA-FACETS-SAFE-P* VARIABLE)"><code>*SYNCING-CUDA-FACETS-SAFE-P*</code></a>)) &amp;BODY BODY</span></span></p>

<p>Update CUDA facets in a possibly asynchronous way while <code>BODY</code>
executes. Behind the scenes, a separate CUDA stream is used to copy
between registered host memory and device memory. When
<code>WITH-SYNCING-CUDA-FACETS</code> finishes either by returning normally or by
a performing a non-local-exit the following are true:</p>

<ul>
<li><p>All <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a>s in <code>MATS-TO-CUDA</code> have an up-to-date
  <a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a> facet.</p></li>
<li><p>All <code>MAT</code>s in <code>MATS-TO-CUDA-HOST</code> have an up-to-date
  <a href="#x-28MGL-MAT-3ACUDA-HOST-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-HOST-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-HOST-ARRAY</code></a> facet and no
  <a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a>.</p></li>
</ul>

<p>It is an error if the same matrix appears in both <code>MATS-TO-CUDA</code> and
<code>MATS-TO-CUDA-HOST</code>, but the same matrix may appear any number of
times in one of them.</p>

<p>If <code>SAFEP</code> is true, then the all matrices in either of the two lists
are effectively locked for output until <code>WITH-SYNCING-CUDA-FACETS</code>
finishes. With SAFE <code>NIL</code>, unsafe accesses to facets of these matrices
are not detected, but the whole operation has a bit less overhead.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ASYNCING-CUDA-FACETS-SAFE-P-2A-20VARIABLE-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-early.lisp#L247">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ASYNCING-CUDA-FACETS-SAFE-P-2A-20VARIABLE-29" >*SYNCING-CUDA-FACETS-SAFE-P*</a></span></span> <span class="locative-args">T</span></span></p>

<p>The default value of the <code>SAFEP</code> argument of
<a href="#x-28MGL-MAT-3AWITH-SYNCING-CUDA-FACETS-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-SYNCING-CUDA-FACETS MGL-PAX:MACRO)"><code>WITH-SYNCING-CUDA-FACETS</code></a>.</p></li>
</ul>

<p>Also note that often the easiest thing to do is to prevent the use
of CUDA (and consequently the creation of <a href="#x-28MGL-MAT-3ACUDA-ARRAY-20MGL-CUBE-3AFACET-NAME-29" title="(MGL-MAT:CUDA-ARRAY MGL-CUBE:FACET-NAME)"><code>CUDA-ARRAY</code></a>
facets, and allocations). This can be done either by binding
<a href="#x-28MGL-MAT-3A-2ACUDA-ENABLED-2A-20VARIABLE-29" title="(MGL-MAT:*CUDA-ENABLED* VARIABLE)"><code>*CUDA-ENABLED*</code></a> to <code>NIL</code> or by setting <a href="#x-28MGL-MAT-3ACUDA-ENABLED-20-28MGL-PAX-3AACCESSOR-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:CUDA-ENABLED (MGL-PAX:ACCESSOR MGL-MAT:MAT))"><code>CUDA-ENABLED</code></a> to <code>NIL</code> on specific
matrices.</p>

<p><a id='x-28MGL-MAT-3A-40MAT-EXTENSIONS-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-MEMORY-MANAGEMENT-20MGL-PAX-3ASECTION-29" title="CUDA Memory Management">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-MANUAL-20MGL-PAX-3ASECTION-29" title="MAT Manual">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-LISP-EXTENSIONS-20MGL-PAX-3ASECTION-29" title="Lisp Extensions">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-EXTENSIONS-20MGL-PAX-3ASECTION-29" title="Writing Extensions">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/mat.lisp#L2449">&#955;</a></span></span></p>

<h2><a href="#x-28MGL-MAT-3A-40MAT-EXTENSIONS-20MGL-PAX-3ASECTION-29">19 Writing Extensions</a></h2>

<p>New operations are usually implemented in lisp, CUDA, or by calling
a foreign function in, for instance, BLAS, CUBLAS, CURAND.</p>

<p><a id='x-28MGL-MAT-3A-40MAT-LISP-EXTENSIONS-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-EXTENSIONS-20MGL-PAX-3ASECTION-29" title="Writing Extensions">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-EXTENSIONS-20MGL-PAX-3ASECTION-29" title="Writing Extensions">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-EXTENSIONS-20MGL-PAX-3ASECTION-29" title="CUDA Extensions">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-LISP-EXTENSIONS-20MGL-PAX-3ASECTION-29" title="Lisp Extensions">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/lisp-kernel.lisp#L5">&#955;</a></span></span></p>

<h3><a href="#x-28MGL-MAT-3A-40MAT-LISP-EXTENSIONS-20MGL-PAX-3ASECTION-29">19.1 Lisp Extensions</a></h3>

<p><a id='x-28MGL-MAT-3ADEFINE-LISP-KERNEL-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/lisp-kernel.lisp#L67">[macro]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ADEFINE-LISP-KERNEL-20MGL-PAX-3AMACRO-29" >DEFINE-LISP-KERNEL</a></span></span> <span class="locative-args">(NAME &amp;KEY (CTYPES '(<code>:FLOAT</code> <code>:DOUBLE</code>))) (&amp;REST <code>PARAMS</code>) &amp;BODY BODY</span></span></p>

<p>This is very much like <a href="#x-28MGL-MAT-3ADEFINE-CUDA-KERNEL-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:DEFINE-CUDA-KERNEL MGL-PAX:MACRO)"><code>DEFINE-CUDA-KERNEL</code></a> but for normal lisp code.
It knows how to deal with <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> objects and can define the same
function for multiple <code>CTYPES</code>. Example:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">define-lisp-kernel</span></i> <span class="paren2">(<span class="code">lisp-.+!</span>)</span>
    <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">alpha <a href="http://www.lispworks.com/reference/HyperSpec/Body/t_short_.htm" class="symbol">single-float</a></span>)</span> <span class="paren3">(<span class="code">x <span class="keyword">:mat</span> <span class="keyword">:input</span></span>)</span> <span class="paren3">(<span class="code">start-x index</span>)</span> <span class="paren3">(<span class="code">n index</span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for xi of-type index upfrom start-x
          below <span class="paren3">(<span class="code">the! index <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> start-x n</span>)</span></span>)</span>
        <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren3">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_incf_.htm" class="symbol">incf</a> <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_aref.htm" class="symbol">aref</a> x xi</span>)</span> alpha</span>)</span></span>)</span></span>)</span></span></code></pre>

<p>Parameters are either of the form <code>(&lt;NAME&gt; &lt;LISP-TYPE)</code>
or <code>(&lt;NAME&gt; :MAT &lt;DIRECTION&gt;)</code>. In the latter case, the appropriate
<code>CFFI</code> pointer is passed to the kernel. <code>&lt;DIRECTION&gt;</code> is passed on to
the <a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACET-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACET MGL-PAX:MACRO)"><code>WITH-FACET</code></a> that's used to acquire the foreign array. Note that
the return type is not declared.</p>

<p>Both the signature and the body are written as if for single floats,
but one function is defined for each ctype in <code>CTYPES</code> by transforming
types, constants and code by substituting them with their ctype
equivalents. Currently this only means that one needs to write only
one kernel for <code>SINGLE-FLOAT</code> and <code>DOUBLE-FLOAT</code>. All such functions get
the declaration from <a href="#x-28MGL-MAT-3A-2ADEFAULT-LISP-KERNEL-DECLARATIONS-2A-20VARIABLE-29" title="(MGL-MAT:*DEFAULT-LISP-KERNEL-DECLARATIONS* VARIABLE)"><code>*DEFAULT-LISP-KERNEL-DECLARATIONS*</code></a>.</p>

<p>Finally, a dispatcher function with <code>NAME</code> is defined which determines
the ctype of the <code>MAT</code> objects passed for <code>:MAT</code> typed parameters. It's
an error if they are not of the same type. Scalars declared
<code>SINGLE-FLOAT</code> are coerced to that type and the appropriate kernel is
called.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ADEFAULT-LISP-KERNEL-DECLARATIONS-2A-20VARIABLE-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/lisp-kernel.lisp#L45">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ADEFAULT-LISP-KERNEL-DECLARATIONS-2A-20VARIABLE-29" >*DEFAULT-LISP-KERNEL-DECLARATIONS*</a></span></span> <span class="locative-args">((OPTIMIZE SPEED (SB-C::INSERT-ARRAY-BOUNDS-CHECKS 0)))</span></span></p>

<p>These declarations are added automatically to kernel functions.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-CUDA-EXTENSIONS-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-LISP-EXTENSIONS-20MGL-PAX-3ASECTION-29" title="Lisp Extensions">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-EXTENSIONS-20MGL-PAX-3ASECTION-29" title="Writing Extensions">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUBLAS-20MGL-PAX-3ASECTION-29" title="CUBLAS">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-EXTENSIONS-20MGL-PAX-3ASECTION-29" title="CUDA Extensions">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-early.lisp#L17">&#955;</a></span></span></p>

<h3><a href="#x-28MGL-MAT-3A-40MAT-CUDA-EXTENSIONS-20MGL-PAX-3ASECTION-29">19.2 CUDA Extensions</a></h3>

<p><a id='x-28MGL-MAT-3AUSE-CUDA-P-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-early.lisp#L46">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AUSE-CUDA-P-20FUNCTION-29" >USE-CUDA-P</a></span></span> <span class="locative-args">&amp;REST MATS</span></span></p>

<p>Return true if cuda is enabled (<a href="#x-28MGL-MAT-3A-2ACUDA-ENABLED-2A-20VARIABLE-29" title="(MGL-MAT:*CUDA-ENABLED* VARIABLE)"><code>*CUDA-ENABLED*</code></a>), it's initialized
and all <code>MATS</code> have <a href="#x-28MGL-MAT-3ACUDA-ENABLED-20-28MGL-PAX-3AACCESSOR-20MGL-MAT-3AMAT-29-29" title="(MGL-MAT:CUDA-ENABLED (MGL-PAX:ACCESSOR MGL-MAT:MAT))"><code>CUDA-ENABLED</code></a>. Operations of
matrices use this to decide whether to go for the CUDA
implementation or BLAS/Lisp. It's provided for implementing new
operations.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ACHOOSE-1D-BLOCK-AND-GRID-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-early.lisp#L68">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACHOOSE-1D-BLOCK-AND-GRID-20FUNCTION-29" >CHOOSE-1D-BLOCK-AND-GRID</a></span></span> <span class="locative-args">N MAX-N-WARPS-PER-BLOCK</span></span></p>

<p>Return two values, one suitable as the <code>:BLOCK-DIM</code>, the other as
the <code>:GRID-DIM</code> argument for a cuda kernel call where both are
one-dimensional (only the first element may be different from 1).</p>

<p>The number of threads in a block is a multiple of <code>*CUDA-WARP-SIZE*</code>.
The number of blocks is between 1 and and <code>*CUDA-MAX-N-BLOCKS*</code>. This
means that the kernel must be able handle any number of elements in
each thread. For example, a strided kernel that adds a constant to
each element of a length <code>N</code> vector looks like this:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">stride <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> block-dim-x grid-dim-x</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">i <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> <span class="paren6">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> block-dim-x block-idx-x</span>)</span> thread-idx-x</span>)</span>
          <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> i stride</span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">&gt;= i n</span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_set.htm" class="symbol">set</a> <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_aref.htm" class="symbol">aref</a> x i</span>)</span> <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_aref.htm" class="symbol">aref</a> x i</span>)</span> alpha</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>It is often the most efficient to have <code>MAX-N-WARPS-PER-BLOCK</code> around
4. Note that the maximum number of threads per block is limited by
hardware (512 for compute capability &lt; 2.0, 1024 for later
versions), so <code>*CUDA-MAX-N-BLOCKS*</code> times <code>MAX-N-WARPS-PER-BLOCK</code> must
not exceed that limit.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3ACHOOSE-2D-BLOCK-AND-GRID-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-early.lisp#L100">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACHOOSE-2D-BLOCK-AND-GRID-20FUNCTION-29" >CHOOSE-2D-BLOCK-AND-GRID</a></span></span> <span class="locative-args">DIMENSIONS MAX-N-WARPS-PER-BLOCK</span></span></p>

<p>Return two values, one suitable as the <code>:BLOCK-DIM</code>, the other as
the <code>:GRID-DIM</code> argument for a cuda kernel call where both are
two-dimensional (only the first two elements may be different from
1).</p>

<p>The number of threads in a block is a multiple of <code>*CUDA-WARP-SIZE*</code>.
The number of blocks is between 1 and and <code>*CUDA-MAX-N-BLOCKS*</code>.
Currently - but this may change - the <code>BLOCK-DIM-X</code> is always
<code>*CUDA-WARP-SIZE*</code> and <code>GRID-DIM-X</code> is always 1.</p>

<p>This means that the kernel must be able handle any number of
elements in each thread. For example, a strided kernel that adds a
constant to each element of a HEIGHT*WIDTH matrix looks like this:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">id-x <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> block-dim-x block-idx-x</span>)</span> thread-idx-x</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">id-y <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> block-dim-y block-idx-y</span>)</span> thread-idx-y</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">stride-x <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> block-dim-x grid-dim-x</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">stride-y <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> block-dim-y grid-dim-y</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">row id-y <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> row stride-y</span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">&gt;= row height</span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">i <span class="paren6">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> row width</span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren5">(<span class="code"><span class="paren6">(<span class="code">column id-x <span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> column stride-x</span>)</span></span>)</span></span>)</span>
          <span class="paren5">(<span class="code"><span class="paren6">(<span class="code">&gt;= column width</span>)</span></span>)</span>
        <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_set.htm" class="symbol">set</a> <span class="paren6">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_aref.htm" class="symbol">aref</a> x i</span>)</span> <span class="paren6">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> <span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_aref.htm" class="symbol">aref</a> x i</span>)</span> alpha</span>)</span></span>)</span>
        <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_incf_.htm" class="symbol">incf</a> i stride-x</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre></li>
</ul>

<p><a id='x-28MGL-MAT-3ACHOOSE-3D-BLOCK-AND-GRID-20FUNCTION-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-early.lisp#L137">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACHOOSE-3D-BLOCK-AND-GRID-20FUNCTION-29" >CHOOSE-3D-BLOCK-AND-GRID</a></span></span> <span class="locative-args">DIMENSIONS MAX-N-WARPS-PER-BLOCK</span></span></p>

<p>Return two values, one suitable as the <code>:BLOCK-DIM</code>, the other as
the <code>:GRID-DIM</code> argument for a cuda kernel call where both are
two-dimensional (only the first two elements may be different from
1).</p>

<p>The number of threads in a block is a multiple of <code>*CUDA-WARP-SIZE*</code>.
The number of blocks is between 1 and and <code>*CUDA-MAX-N-BLOCKS*</code>.
Currently - but this may change - the <code>BLOCK-DIM-X</code> is always
<code>*CUDA-WARP-SIZE*</code> and <code>GRID-DIM-X</code> is always 1.</p>

<p>This means that the kernel must be able handle any number of
elements in each thread. For example, a strided kernel that adds a
constant to each element of a <code>THICKNESS</code> * <code>HEIGHT</code> * <code>WIDTH</code> 3d array
looks like this:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">id-x <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> block-dim-x block-idx-x</span>)</span> thread-idx-x</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">id-y <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> block-dim-y block-idx-y</span>)</span> thread-idx-y</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">id-z <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> block-dim-z block-idx-z</span>)</span> thread-idx-z</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">stride-x <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> block-dim-x grid-dim-x</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">stride-y <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> block-dim-y grid-dim-y</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">stride-z <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> block-dim-z grid-dim-z</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">plane id-z <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> plane stride-z</span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">&gt;= plane thickness</span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">row id-y <span class="paren6">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> row stride-y</span>)</span></span>)</span></span>)</span>
        <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">&gt;= row height</span>)</span></span>)</span>
      <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren5">(<span class="code"><span class="paren6">(<span class="code">i <span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> <span class="paren2">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> <span class="paren3">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> plane height</span>)</span> row</span>)</span>
                  width</span>)</span></span>)</span></span>)</span>
        <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren6">(<span class="code"><span class="paren1">(<span class="code">column id-x <span class="paren2">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> column stride-x</span>)</span></span>)</span></span>)</span>
            <span class="paren6">(<span class="code"><span class="paren1">(<span class="code">&gt;= column width</span>)</span></span>)</span>
          <span class="paren6">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_set.htm" class="symbol">set</a> <span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_aref.htm" class="symbol">aref</a> x i</span>)</span> <span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> <span class="paren2">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_aref.htm" class="symbol">aref</a> x i</span>)</span> alpha</span>)</span></span>)</span>
          <span class="paren6">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_incf_.htm" class="symbol">incf</a> i stride-x</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre></li>
</ul>

<p><a id='x-28MGL-MAT-3ADEFINE-CUDA-KERNEL-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cuda-kernel.lisp#L62">[macro]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ADEFINE-CUDA-KERNEL-20MGL-PAX-3AMACRO-29" >DEFINE-CUDA-KERNEL</a></span></span> <span class="locative-args">(NAME &amp;KEY (CTYPES '(<code>:FLOAT</code> <code>:DOUBLE</code>))) (RETURN-TYPE <code>PARAMS</code>) &amp;BODY BODY</span></span></p>

<p>This is an extended <code>CL-CUDA:DEFKERNEL</code> macro. It knows how to deal
with <a href="#x-28MGL-MAT-3AMAT-20CLASS-29" title="(MGL-MAT:MAT CLASS)"><code>MAT</code></a> objects and can define the same function for multiple
<code>CTYPES</code>. Example:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">define-cuda-kernel</span></i> <span class="paren2">(<span class="code">cuda-.+!</span>)</span>
    <span class="paren2">(<span class="code">void <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">alpha <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_float.htm" class="symbol">float</a></span>)</span> <span class="paren4">(<span class="code">x <span class="keyword">:mat</span> <span class="keyword">:input</span></span>)</span> <span class="paren4">(<span class="code">n int</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">stride <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> block-dim-x grid-dim-x</span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">i <span class="paren6">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> <span class="paren1">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> block-dim-x block-idx-x</span>)</span> thread-idx-x</span>)</span>
            <span class="paren6">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> i stride</span>)</span></span>)</span></span>)</span>
        <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">&gt;= i n</span>)</span></span>)</span>
      <span class="paren4">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_set.htm" class="symbol">set</a> <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_aref.htm" class="symbol">aref</a> x i</span>)</span> <span class="paren5">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> <span class="paren6">(<span class="code"><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_aref.htm" class="symbol">aref</a> x i</span>)</span> alpha</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>The signature looks pretty much like in <code>CL-CUDA:DEFKERNEL</code>, but
parameters can take the form of <code>(&lt;NAME&gt; :MAT &lt;DIRECTION&gt;)</code> too, in
which case the appropriate <code>CL-CUDA.DRIVER-API:CU-DEVICE-PTR</code> is
passed to the kernel. <code>&lt;DIRECTION&gt;</code> is passed on to the <a href="cube-manual.html#x-28MGL-CUBE-3AWITH-FACET-20MGL-PAX-3AMACRO-29" title="(MGL-CUBE:WITH-FACET MGL-PAX:MACRO)"><code>WITH-FACET</code></a>
that's used to acquire the cuda array.</p>

<p>Both the signature and the body are written as if for single floats,
but one function is defined for each ctype in <code>CTYPES</code> by transforming
types, constants and code by substituting them with their ctype
equivalents. Currently this only means that one needs to write only
one kernel for <code>FLOAT</code> and <code>DOUBLE</code>.</p>

<p>Finally, a dispatcher function with <code>NAME</code> is defined which determines
the ctype of the <code>MAT</code> objects passed for <code>:MAT</code> typed parameters. It's
an error if they are not of the same type. Scalars declared <code>FLOAT</code>
are coerced to that type and the appropriate kernel is called.</p></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-CUBLAS-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-EXTENSIONS-20MGL-PAX-3ASECTION-29" title="CUDA Extensions">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-EXTENSIONS-20MGL-PAX-3ASECTION-29" title="CUDA Extensions">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-CURAND-20MGL-PAX-3ASECTION-29" title="CURAND">&#8594;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUBLAS-20MGL-PAX-3ASECTION-29" title="CUBLAS">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cublas.lisp#L15">&#955;</a></span></span></p>

<h4><a href="#x-28MGL-MAT-3A-40MAT-CUBLAS-20MGL-PAX-3ASECTION-29">19.2.1 CUBLAS</a></h4>

<p>In a <a href="#x-28MGL-MAT-3AWITH-CUDA-2A-20MGL-PAX-3AMACRO-29" title="(MGL-MAT:WITH-CUDA* MGL-PAX:MACRO)"><code>WITH-CUDA*</code></a> <a href="#x-28MGL-MAT-3A-40MAT-BLAS-20MGL-PAX-3ASECTION-29" title="BLAS Operations">BLAS Operations</a> will automatically use CUBLAS. No need to
use these at all.</p>

<p><a id='x-28MGL-MAT-3ACUBLAS-ERROR-20CONDITION-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cublas.lisp#L68">[condition]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACUBLAS-ERROR-20CONDITION-29" >CUBLAS-ERROR</a></span></span> <span class="locative-args">ERROR</span></span></li>
</ul>

<p><a id='x-28MGL-MAT-3ACUBLAS-ERROR-FUNCTION-NAME-20-28MGL-PAX-3AREADER-20MGL-MAT-3ACUBLAS-ERROR-29-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cublas.lisp#L68">[reader]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACUBLAS-ERROR-FUNCTION-NAME-20-28MGL-PAX-3AREADER-20MGL-MAT-3ACUBLAS-ERROR-29-29" >CUBLAS-ERROR-FUNCTION-NAME</a></span></span> <span class="locative-args">CUBLAS-ERROR</span> <span class="locative-args">(:FUNCTION-NAME)</span></span></li>
</ul>

<p><a id='x-28MGL-MAT-3ACUBLAS-ERROR-STATUS-20-28MGL-PAX-3AREADER-20MGL-MAT-3ACUBLAS-ERROR-29-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cublas.lisp#L68">[reader]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACUBLAS-ERROR-STATUS-20-28MGL-PAX-3AREADER-20MGL-MAT-3ACUBLAS-ERROR-29-29" >CUBLAS-ERROR-STATUS</a></span></span> <span class="locative-args">CUBLAS-ERROR</span> <span class="locative-args">(:STATUS)</span></span></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ACUBLAS-HANDLE-2A-20VARIABLE-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cublas.lisp#L82">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ACUBLAS-HANDLE-2A-20VARIABLE-29" >*CUBLAS-HANDLE*</a></span></span> <span class="locative-args">&quot;-unbound-&quot;</span></span></li>
</ul>

<p><a id='x-28MGL-MAT-3ACUBLAS-CREATE-20FUNCTION-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cublas.lisp#L79">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACUBLAS-CREATE-20FUNCTION-29" >CUBLAS-CREATE</a></span></span> <span class="locative-args">HANDLE</span></span></li>
</ul>

<p><a id='x-28MGL-MAT-3ACUBLAS-DESTROY-20FUNCTION-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cublas.lisp#L84">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACUBLAS-DESTROY-20FUNCTION-29" >CUBLAS-DESTROY</a></span></span> <span class="locative-args">&amp;KEY (HANDLE <a href="#x-28MGL-MAT-3A-2ACUBLAS-HANDLE-2A-20VARIABLE-29" title="(MGL-MAT:*CUBLAS-HANDLE* VARIABLE)"><code>*CUBLAS-HANDLE*</code></a>)</span></span></li>
</ul>

<p><a id='x-28MGL-MAT-3AWITH-CUBLAS-HANDLE-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cublas.lisp#L86">[macro]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AWITH-CUBLAS-HANDLE-20MGL-PAX-3AMACRO-29" >WITH-CUBLAS-HANDLE</a></span></span> <span class="locative-args">NIL &amp;BODY BODY</span></span></li>
</ul>

<p><a id='x-28MGL-MAT-3ACUBLAS-GET-VERSION-20FUNCTION-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/cublas.lisp#L95">[function]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACUBLAS-GET-VERSION-20FUNCTION-29" >CUBLAS-GET-VERSION</a></span></span> <span class="locative-args">VERSION &amp;KEY (HANDLE <a href="#x-28MGL-MAT-3A-2ACUBLAS-HANDLE-2A-20VARIABLE-29" title="(MGL-MAT:*CUBLAS-HANDLE* VARIABLE)"><code>*CUBLAS-HANDLE*</code></a>)</span></span></li>
</ul>

<p><a id='x-28MGL-MAT-3A-40MAT-CURAND-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-MAT-3A-40MAT-CUBLAS-20MGL-PAX-3ASECTION-29" title="CUBLAS">&#8592;</a> <a href="#x-28MGL-MAT-3A-40MAT-CUDA-EXTENSIONS-20MGL-PAX-3ASECTION-29" title="CUDA Extensions">&#8593;</a> <a href="#x-28MGL-MAT-3A-40MAT-CURAND-20MGL-PAX-3ASECTION-29" title="CURAND">&#8634;</a> <a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/curand.lisp#L3">&#955;</a></span></span></p>

<h4><a href="#x-28MGL-MAT-3A-40MAT-CURAND-20MGL-PAX-3ASECTION-29">19.2.2 CURAND</a></h4>

<p>This the low level CURAND API. You probably want <a href="#x-28MGL-MAT-3A-40MAT-RANDOM-20MGL-PAX-3ASECTION-29" title="Random numbers">Random numbers</a>
instead.</p>

<p><a id='x-28MGL-MAT-3AWITH-CURAND-STATE-20MGL-PAX-3AMACRO-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/curand.lisp#L17">[macro]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AWITH-CURAND-STATE-20MGL-PAX-3AMACRO-29" >WITH-CURAND-STATE</a></span></span> <span class="locative-args">(STATE) &amp;BODY BODY</span></span></li>
</ul>

<p><a id='x-28MGL-MAT-3A-2ACURAND-STATE-2A-20VARIABLE-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/curand.lisp#L12">[variable]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3A-2ACURAND-STATE-2A-20VARIABLE-29" >*CURAND-STATE*</a></span></span> <span class="locative-args">&quot;-unbound-&quot;</span></span></li>
</ul>

<p><a id='x-28MGL-MAT-3ACURAND-XORWOW-STATE-20CLASS-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/curand.lisp#L33">[class]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ACURAND-XORWOW-STATE-20CLASS-29" >CURAND-XORWOW-STATE</a></span></span></span></li>
</ul>

<p><a id='x-28MGL-MAT-3AN-STATES-20-28MGL-PAX-3AREADER-20MGL-MAT-3ACURAND-XORWOW-STATE-29-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/curand.lisp#L34">[reader]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3AN-STATES-20-28MGL-PAX-3AREADER-20MGL-MAT-3ACURAND-XORWOW-STATE-29-29" >N-STATES</a></span></span> <span class="locative-args">CURAND-XORWOW-STATE</span> <span class="locative-args">(:N-STATES)</span></span></li>
</ul>

<p><a id='x-28MGL-MAT-3ASTATES-20-28MGL-PAX-3AREADER-20MGL-MAT-3ACURAND-XORWOW-STATE-29-29'></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/mgl-mat/blob/2ded4de8a0e7180d763b452037ab3cf8ee781d40/src/curand.lisp#L35">[reader]</a></span> <span class="reference-object"><a href="#x-28MGL-MAT-3ASTATES-20-28MGL-PAX-3AREADER-20MGL-MAT-3ACURAND-XORWOW-STATE-29-29" >STATES</a></span></span> <span class="locative-args">CURAND-XORWOW-STATE</span> <span class="locative-args">(:STATES)</span></span></li>
</ul>
  </div>
</div>
<script>$('#page-toc').toc({'selectors': 'h1,h2,h3,h4'});</script>
</body>
</html>
