<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<head>
<title>Micmac Manual</title>
<link type='text/css' href='style.css' rel='stylesheet'/>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<script src="jquery.min.js"></script>
<script src="toc.min.js"></script>
<script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {
         inlineMath: [['$','$']],
         processEscapes: true
       }
     });
   </script>
   <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
   </script>
   </head>
<body>
<div id="content-container">
<div id="toc">
<div id="toc-header"><ul><li><a href="index.html">PAX World</a></li></ul></div>
<div id="page-toc">
</div>
<div id="toc-footer"><ul><li><a href="https://github.com/melisgl/mgl-pax">[generated by MGL-PAX]</a></li></ul></div>
</div>
<div id="content">
<p><a id="x-28MICMAC-3A-40MICMAC-MANUAL-20MGL-PAX-3ASECTION-29"></a>
<a id="MICMAC:@MICMAC-MANUAL%20MGL-PAX:SECTION"></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#%22micmac%22%20ASDF%2FSYSTEM:SYSTEM" title="&quot;micmac&quot; ASDF/SYSTEM:SYSTEM">&#8594;</a> <a href="#MICMAC:@MICMAC-MANUAL%20MGL-PAX:SECTION" title="Micmac Manual">&#8634;</a> <a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/micmac.lisp#L3">&#955;</a></span></span></p>

<h1><a href="#MICMAC:@MICMAC-MANUAL%20MGL-PAX:SECTION">Micmac Manual</a></h1>

<h2>Table of Contents</h2>

<ul>
<li><a href="#%22micmac%22%20ASDF%2FSYSTEM:SYSTEM" title="&quot;micmac&quot; ASDF/SYSTEM:SYSTEM">1 MICMAC ASDF System Details</a></li>
<li><a href="#MICMAC:@MICMAC-INTRODUCTION%20MGL-PAX:SECTION" title="Introduction">2 Introduction</a>

<ul>
<li><a href="#MICMAC:@MICMAC-OVERVIEW%20MGL-PAX:SECTION" title="Overview">2.1 Overview</a></li>
<li><a href="#MICMAC:@MICMAC-LINKS%20MGL-PAX:SECTION" title="Links">2.2 Links</a></li>
</ul></li>
<li><a href="#MICMAC:@MICMAC-GRAPH-SEARCH%20MGL-PAX:SECTION" title="Graph Search">3 Graph Search</a>

<ul>
<li><a href="#MICMAC.UCT:@MICMAC-UCT%20MGL-PAX:SECTION" title="UCT">3.1 UCT</a></li>
</ul></li>
<li><a href="#MICMAC.METROPOLIS-HASTINGS:@MICMAC-METROPOLIS-HASTINGS%20MGL-PAX:SECTION" title="Metropolis Hastings">4 Metropolis Hastings</a></li>
<li><a href="#MICMAC.GAME-THEORY:@MICMAC-GAME-THEORY%20MGL-PAX:SECTION" title="Game Theory">5 Game Theory</a></li>
</ul>

<h6>[in package MICMAC]</h6>

<p><a id="x-28-22micmac-22-20ASDF-2FSYSTEM-3ASYSTEM-29"></a>
<a id="%22micmac%22%20ASDF%2FSYSTEM:SYSTEM"></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#MICMAC:@MICMAC-MANUAL%20MGL-PAX:SECTION" title="Micmac Manual">&#8592;</a> <a href="#MICMAC:@MICMAC-MANUAL%20MGL-PAX:SECTION" title="Micmac Manual">&#8593;</a> <a href="#MICMAC:@MICMAC-INTRODUCTION%20MGL-PAX:SECTION" title="Introduction">&#8594;</a> <a href="#%22micmac%22%20ASDF%2FSYSTEM:SYSTEM" title="&quot;micmac&quot; ASDF/SYSTEM:SYSTEM">&#8634;</a> <a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/micmac.asd#L1">&#955;</a></span></span></p>

<h2><a href="#%22micmac%22%20ASDF%2FSYSTEM:SYSTEM">1 MICMAC ASDF System Details</a></h2>

<ul>
<li>Version: 0.0.2</li>
<li>Description: Micmac is mainly a library of graph search algorithms
  such as alpha-beta, UCT and beam search, but it also has some MCMC
  and other slightly unrelated stuff.</li>
<li>Licence: MIT, see COPYING.</li>
<li>Author: Gábor Melis <a href="m&#x61;&#105;l&#x74;&#111;:&#x6D;&#101;g&#x61;&#64;r&#x65;&#116;e&#x73;&#46;h&#x75;">m&#x61;&#105;l&#x74;&#111;:&#x6D;&#101;g&#x61;&#64;r&#x65;&#116;e&#x73;&#46;h&#x75;</a></li>
<li>Mailto: <a href="mailto:mega@retes.hu" >mega@retes.hu</a></li>
<li>Homepage: <a href="http://melisgl.github.io/mgl-gpr" >http://melisgl.github.io/mgl-gpr</a></li>
<li>Bug tracker: <a href="https://github.com/melisgl/mgl-gpr/issues" >https://github.com/melisgl/mgl-gpr/issues</a></li>
<li>Source control: <a href="https://github.com/melisgl/mgl-gpr.git" >GIT</a></li>
</ul>

<p><a id="x-28MICMAC-3A-40MICMAC-INTRODUCTION-20MGL-PAX-3ASECTION-29"></a>
<a id="MICMAC:@MICMAC-INTRODUCTION%20MGL-PAX:SECTION"></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#%22micmac%22%20ASDF%2FSYSTEM:SYSTEM" title="&quot;micmac&quot; ASDF/SYSTEM:SYSTEM">&#8592;</a> <a href="#MICMAC:@MICMAC-MANUAL%20MGL-PAX:SECTION" title="Micmac Manual">&#8593;</a> <a href="#MICMAC:@MICMAC-OVERVIEW%20MGL-PAX:SECTION" title="Overview">&#8594;</a> <a href="#MICMAC:@MICMAC-INTRODUCTION%20MGL-PAX:SECTION" title="Introduction">&#8634;</a> <a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/micmac.lisp#L10">&#955;</a></span></span></p>

<h2><a href="#MICMAC:@MICMAC-INTRODUCTION%20MGL-PAX:SECTION">2 Introduction</a></h2>

<p><a id="x-28MICMAC-3A-40MICMAC-OVERVIEW-20MGL-PAX-3ASECTION-29"></a>
<a id="MICMAC:@MICMAC-OVERVIEW%20MGL-PAX:SECTION"></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#MICMAC:@MICMAC-INTRODUCTION%20MGL-PAX:SECTION" title="Introduction">&#8592;</a> <a href="#MICMAC:@MICMAC-INTRODUCTION%20MGL-PAX:SECTION" title="Introduction">&#8593;</a> <a href="#MICMAC:@MICMAC-LINKS%20MGL-PAX:SECTION" title="Links">&#8594;</a> <a href="#MICMAC:@MICMAC-OVERVIEW%20MGL-PAX:SECTION" title="Overview">&#8634;</a> <a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/micmac.lisp#L14">&#955;</a></span></span></p>

<h3><a href="#MICMAC:@MICMAC-OVERVIEW%20MGL-PAX:SECTION">2.1 Overview</a></h3>

<p>MICMAC is a Common Lisp library by <a href="http://quotenil.com" >Gábor
Melis</a> focusing on <a href="http://en.wikipedia.org/wiki/Graph_traversal" >graph
search</a> algorithms.</p>

<p><a id="x-28MICMAC-3A-40MICMAC-LINKS-20MGL-PAX-3ASECTION-29"></a>
<a id="MICMAC:@MICMAC-LINKS%20MGL-PAX:SECTION"></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#MICMAC:@MICMAC-OVERVIEW%20MGL-PAX:SECTION" title="Overview">&#8592;</a> <a href="#MICMAC:@MICMAC-INTRODUCTION%20MGL-PAX:SECTION" title="Introduction">&#8593;</a> <a href="#MICMAC:@MICMAC-GRAPH-SEARCH%20MGL-PAX:SECTION" title="Graph Search">&#8594;</a> <a href="#MICMAC:@MICMAC-LINKS%20MGL-PAX:SECTION" title="Links">&#8634;</a> <a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/micmac.lisp#L19">&#955;</a></span></span></p>

<h3><a href="#MICMAC:@MICMAC-LINKS%20MGL-PAX:SECTION">2.2 Links</a></h3>

<p>Here is the <a href="https://github.com/melisgl/micmac" >official
repository</a> and the <a href="http://melisgl.github.io/mgl-pax-world/micmac-manual.html" >HTML
documentation</a>
for the latest version.</p>

<p><a id="x-28MICMAC-3A-40MICMAC-GRAPH-SEARCH-20MGL-PAX-3ASECTION-29"></a>
<a id="MICMAC:@MICMAC-GRAPH-SEARCH%20MGL-PAX:SECTION"></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#MICMAC:@MICMAC-LINKS%20MGL-PAX:SECTION" title="Links">&#8592;</a> <a href="#MICMAC:@MICMAC-MANUAL%20MGL-PAX:SECTION" title="Micmac Manual">&#8593;</a> <a href="#MICMAC.UCT:@MICMAC-UCT%20MGL-PAX:SECTION" title="UCT">&#8594;</a> <a href="#MICMAC:@MICMAC-GRAPH-SEARCH%20MGL-PAX:SECTION" title="Graph Search">&#8634;</a> <a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/graph-search.lisp#L3">&#955;</a></span></span></p>

<h2><a href="#MICMAC:@MICMAC-GRAPH-SEARCH%20MGL-PAX:SECTION">3 Graph Search</a></h2>

<p><a id="x-28MICMAC-3AALPHA-BETA-20FUNCTION-29"></a>
<a id="MICMAC:ALPHA-BETA%20FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/graph-search.lisp#L9">[function]</a></span> <span class="reference-object"><a href="#MICMAC:ALPHA-BETA%20FUNCTION" >alpha-beta</a></span></span> <span class="locative-args">state &amp;key (depth 0) alpha beta call-with-action maybe-evaluate-state list-actions record-best</span></span></p>

<p>Alpha-beta pruning for two player, zero-sum maximax (like minimax
but both players maximize and the score is negated when passed
between depths). Return the score of the game <code>state</code> from the point
of view of the player to move at <code>depth</code> and as the second value the
list of actions of the principal variant.</p>

<p><code>call-with-action</code> is a function of (<code>state</code> <code>depth</code> <code>action</code> FN). It
carries out <code>action</code> (returned by <code>list-actions</code> or <code>nil</code>) to get the
state corresponding to <code>depth</code> and calls FN with that state. It may
destructively modify <code>state</code> provided it undoes the damage after FN
returns. <code>call-with-action</code> is called with <code>nil</code> as <code>action</code> for the root
of the tree, in this case <code>state</code> need not be changed. FN returns the
same kinds of values as <code>alpha-beta</code>. They may be useful for logging.</p>

<p><code>maybe-evaluate-state</code> is a function of (<code>state</code> <code>depth</code>). If <code>state</code> at
<code>depth</code> is a terminal node then it returns the score from the point of
view of the player to move and as the second value a list of actions
that lead from <code>state</code> to the position that was evaluated. The list of
actions is typically empty. If we are not at a terminal node then
<code>maybe-evaluate-state</code> returns <code>nil</code>.</p>

<p><code>list-actions</code> is a function of (<code>state</code> <code>depth</code>) and returns a non-empty
list of legal candidate moves for non-terminal nodes. Actions are
tried in the order <code>list-actions</code> returns them: stronger moves</p>

<p><code>call-with-action</code>, <code>maybe-evaluate-state</code> and <code>list-actions</code> are
mandatory.</p>

<p><code>record-best</code>, if non-NIL, is a function of (<code>depth</code> <code>score</code> <code>actions</code>). It
is called when at <code>depth</code> a new best action is found. <code>actions</code> is a
list of all the actions in the principle variant corresonding to the
newly found best score. <code>record-best</code> is useful for graceful
degradation in case of timeout.</p>

<p><code>alpha</code> and <code>beta</code> are typically <code>nil</code> (equivalent to -infinity,
+infinity) but any real number is allowed if the range of scores can
be boxed.</p>

<p>See <code>test/test-alpha-beta.lisp</code> for an example.</p></li>
</ul>

<p><a id="x-28MICMAC-3ABEAM-SEARCH-20FUNCTION-29"></a>
<a id="MICMAC:BEAM-SEARCH%20FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/graph-search.lisp#L87">[function]</a></span> <span class="reference-object"><a href="#MICMAC:BEAM-SEARCH%20FUNCTION" >beam-search</a></span></span> <span class="locative-args">start-nodes &amp;key max-depth (n-solutions 1) (beam-width (length start-nodes)) expand-node-fn expand-beam-fn score-fn upper-bound-fn solutionp-fn (finishedp-fn solutionp-fn)</span></span></p>

<p>In a graph, search for nodes that with the best scores with <a href="http://en.wikipedia.org/wiki/Beam_search" >beam
search</a>. That is, starting
from <code>start-nodes</code> perform a breadth-first search but at each depth
only keep <code>beam-width</code> number of nodes with the best scores. Keep the
best <code>n-solutions</code> (at most) complete solutions. Discard nodes known
to be unable to get into the best <code>n-solutions</code> (due to
<code>upper-bound-fn</code>). Finally, return the solutions and the active
nodes (the <em>beam</em>) as adjustable arrays sorted by score in
descending order.</p>

<p><code>start-nodes</code> (a sequence of elements of arbitrary type). <code>score-fn</code>,
<code>upper-bound-fn</code>, <code>solutionp-fn</code>, <code>finishedp-fn</code> are all functions of one
argument: the node. <code>solutionp-fn</code> checks whether a node represents a
complete solution (i.e. some goal is reached). <code>score-fn</code> returns a
real number that's to be maximized, it's only called for node for
which <code>solutionp-fn</code> returned true. <code>upper-bound-fn</code> (if not <code>nil</code>)
returns a real number that equal or greater than the score of all
solutions reachable from that node. <code>finishedp-fn</code> returns true iff
there is nowhere to go from the node.</p>

<p><code>expand-node-fn</code> is also a function of a single node argument. It
returns a sequence of nodes to 'one step away' from its argument
node. <code>expand-beam-fn</code> is similar, but it takes a vector of nodes and
returns all nodes one step away from any of them. It's enough
provide either <code>expand-node-fn</code> or <code>expand-beam-fn</code>. The purpose of
<code>expand-beam-fn</code>. is to allow more efficient, batch-like operations.</p>

<p>See <code>test/test-beam-search.lisp</code> for an example.</p></li>
</ul>

<p><a id="x-28MICMAC-3APARALLEL-BEAM-SEARCH-20FUNCTION-29"></a>
<a id="MICMAC:PARALLEL-BEAM-SEARCH%20FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/graph-search.lisp#L154">[function]</a></span> <span class="reference-object"><a href="#MICMAC:PARALLEL-BEAM-SEARCH%20FUNCTION" >parallel-beam-search</a></span></span> <span class="locative-args">start-node-seqs &amp;key max-depth (n-solutions 1) beam-width expand-node-fn expand-beams-fn score-fn upper-bound-fn solutionp-fn (finishedp-fn solutionp-fn)</span></span></p>

<p>This is very much like <a href="#MICMAC:BEAM-SEARCH%20FUNCTION" title="MICMAC:BEAM-SEARCH FUNCTION"><code>beam-search</code></a> except it solves a number of
instances of the same search problem starting from different sets of
nodes. The sole purpose of <code>parallel-beam-search</code> is to amortize the
cost <code>expand-beam-fn</code> if possible.</p>

<p><code>expand-beams-fn</code> is called with sequence of beams (i.e. it's a
sequence of sequence of nodes) and it must return another sequence
of sequences of nodes. Each element of the returned sequence is the
reachable nodes of the nodes in the corresponding element of its
argument sequence.</p>

<p><code>parallel-beam-search</code> returns a sequence of solutions sequences, and
a sequence of active node sequences.</p>

<p>See <code>test/test-beam-search.lisp</code> for an example.</p></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3A-40MICMAC-UCT-20MGL-PAX-3ASECTION-29"></a>
<a id="MICMAC.UCT:@MICMAC-UCT%20MGL-PAX:SECTION"></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#MICMAC:@MICMAC-GRAPH-SEARCH%20MGL-PAX:SECTION" title="Graph Search">&#8592;</a> <a href="#MICMAC:@MICMAC-GRAPH-SEARCH%20MGL-PAX:SECTION" title="Graph Search">&#8593;</a> <a href="#MICMAC.METROPOLIS-HASTINGS:@MICMAC-METROPOLIS-HASTINGS%20MGL-PAX:SECTION" title="Metropolis Hastings">&#8594;</a> <a href="#MICMAC.UCT:@MICMAC-UCT%20MGL-PAX:SECTION" title="UCT">&#8634;</a> <a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L3">&#955;</a></span></span></p>

<h3><a href="#MICMAC.UCT:@MICMAC-UCT%20MGL-PAX:SECTION">3.1 UCT</a></h3>

<h6>[in package MICMAC.UCT]</h6>

<p><a href="#MICMAC.UCT:UCT%20FUNCTION" title="MICMAC.UCT:UCT FUNCTION"><code>uct</code></a> Monte Carlo tree search. This is what makes current Go programs
tick. And Hex programs as well, for that matter. This is a cleanup
and generalization of code originally created in course of the
Google AI Challenge 2010.</p>

<p>For now, the documentation is just a reference. See
<code>test/test-uct.lisp</code> for an example.</p>

<p><a id="x-28MICMAC-2EUCT-3AUCT-NODE-20CLASS-29"></a>
<a id="MICMAC.UCT:UCT-NODE%20CLASS"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L31">[class]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:UCT-NODE%20CLASS" >uct-node</a></span></span></span></p>

<p>A node in the <a href="#MICMAC.UCT:UCT%20FUNCTION" title="MICMAC.UCT:UCT FUNCTION"><code>uct</code></a> tree. Roughly translates to a
state in the search space. Note that the state itself is not stored
explicity, but it can be recovered by `replaying' the actions from
the starting state or by customizing <a href="#MICMAC.UCT:MAKE-UCT-NODE%20GENERIC-FUNCTION" title="MICMAC.UCT:MAKE-UCT-NODE GENERIC-FUNCTION"><code>make-uct-node</code></a>.</p></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3ADEPTH-20-28MGL-PAX-3AREADER-20MICMAC-2EUCT-3AUCT-NODE-29-29"></a>
<a id="MICMAC.UCT:DEPTH%20%28MGL-PAX:READER%20MICMAC.UCT:UCT-NODE%29"></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L32">[reader]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:DEPTH%20%28MGL-PAX:READER%20MICMAC.UCT:UCT-NODE%29" >depth</a></span></span> <span class="locative-args">uct-node</span> <span class="locative-args">(:depth = 0)</span></span></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3AEDGES-20-28MGL-PAX-3AACCESSOR-20MICMAC-2EUCT-3AUCT-NODE-29-29"></a>
<a id="MICMAC.UCT:EDGES%20%28MGL-PAX:ACCESSOR%20MICMAC.UCT:UCT-NODE%29"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L36">[accessor]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:EDGES%20%28MGL-PAX:ACCESSOR%20MICMAC.UCT:UCT-NODE%29" >edges</a></span></span> <span class="locative-args">uct-node</span></span></p>

<p>Outgoing edges.</p></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3AAVERAGE-REWARD-20-28MGL-PAX-3AACCESSOR-20MICMAC-2EUCT-3AUCT-NODE-29-29"></a>
<a id="MICMAC.UCT:AVERAGE-REWARD%20%28MGL-PAX:ACCESSOR%20MICMAC.UCT:UCT-NODE%29"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L37">[accessor]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:AVERAGE-REWARD%20%28MGL-PAX:ACCESSOR%20MICMAC.UCT:UCT-NODE%29" >average-reward</a></span></span> <span class="locative-args">uct-node</span> <span class="locative-args">(:average-reward = 0)</span></span></p>

<p>Average reward over random playouts started from
below this node. See <a href="#MICMAC.UCT:UPDATE-UCT-STATISTICS%20GENERIC-FUNCTION" title="MICMAC.UCT:UPDATE-UCT-STATISTICS GENERIC-FUNCTION"><code>update-uct-statistics</code></a> and REWARD.</p></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3AUCT-EDGE-20CLASS-29"></a>
<a id="MICMAC.UCT:UCT-EDGE%20CLASS"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L55">[class]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:UCT-EDGE%20CLASS" >uct-edge</a></span></span></span></p>

<p>An edge in the <a href="#MICMAC.UCT:UCT%20FUNCTION" title="MICMAC.UCT:UCT FUNCTION"><code>uct</code></a> tree. Represents an action taken
from a state. The value of an action is the value of its target
state which is not quite as generic as it could be; feel free to
specialize <a href="#MICMAC.UCT:AVERAGE-REWARD%20%28MGL-PAX:ACCESSOR%20MICMAC.UCT:UCT-NODE%29" title="MICMAC.UCT:AVERAGE-REWARD (MGL-PAX:ACCESSOR MICMAC.UCT:UCT-NODE)"><code>average-reward</code></a> for the edges if that's not the case.</p></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3AACTION-20-28MGL-PAX-3AREADER-20MICMAC-2EUCT-3AUCT-EDGE-29-29"></a>
<a id="MICMAC.UCT:ACTION%20%28MGL-PAX:READER%20MICMAC.UCT:UCT-EDGE%29"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L56">[reader]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:ACTION%20%28MGL-PAX:READER%20MICMAC.UCT:UCT-EDGE%29" >action</a></span></span> <span class="locative-args">uct-edge</span> <span class="locative-args">(:action)</span></span></p>

<p>The action represented by the edge.</p></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3AFROM-NODE-20-28MGL-PAX-3AACCESSOR-20MICMAC-2EUCT-3AUCT-EDGE-29-29"></a>
<a id="MICMAC.UCT:FROM-NODE%20%28MGL-PAX:ACCESSOR%20MICMAC.UCT:UCT-EDGE%29"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L59">[accessor]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:FROM-NODE%20%28MGL-PAX:ACCESSOR%20MICMAC.UCT:UCT-EDGE%29" >from-node</a></span></span> <span class="locative-args">uct-edge</span> <span class="locative-args">(:from-node)</span></span></p>

<p>The node this edge starts from.</p></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3ATO-NODE-20-28MGL-PAX-3AACCESSOR-20MICMAC-2EUCT-3AUCT-EDGE-29-29"></a>
<a id="MICMAC.UCT:TO-NODE%20%28MGL-PAX:ACCESSOR%20MICMAC.UCT:UCT-EDGE%29"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L62">[accessor]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:TO-NODE%20%28MGL-PAX:ACCESSOR%20MICMAC.UCT:UCT-EDGE%29" >to-node</a></span></span> <span class="locative-args">uct-edge</span> <span class="locative-args">(= nil)</span></span></p>

<p>The node this edge points to if the edge has been
visited or <code>nil</code>.</p></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3AVISITED-EDGES-20FUNCTION-29"></a>
<a id="MICMAC.UCT:VISITED-EDGES%20FUNCTION"></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L98">[function]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:VISITED-EDGES%20FUNCTION" >visited-edges</a></span></span> <span class="locative-args">node</span></span></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3AUNVISITED-EDGES-20FUNCTION-29"></a>
<a id="MICMAC.UCT:UNVISITED-EDGES%20FUNCTION"></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L101">[function]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:UNVISITED-EDGES%20FUNCTION" >unvisited-edges</a></span></span> <span class="locative-args">node</span></span></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3AEDGE-SCORE-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.UCT:EDGE-SCORE%20GENERIC-FUNCTION"></a></p>

<ul>
<li><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L104">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:EDGE-SCORE%20GENERIC-FUNCTION" >edge-score</a></span></span> <span class="locative-args">node edge exploration-bias</span></span></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3ASELECT-EDGE-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.UCT:SELECT-EDGE%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L111">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:SELECT-EDGE%20GENERIC-FUNCTION" >select-edge</a></span></span> <span class="locative-args">node exploration-bias</span></span></p>

<p>Choose an action to take from a state, in other
words an edge to follow from <code>node</code> in the tree. The default
implementation chooses randomly from the yet unvisited edges or if
there is none moves down the edge with the maximum <a href="#MICMAC.UCT:EDGE-SCORE%20GENERIC-FUNCTION" title="MICMAC.UCT:EDGE-SCORE GENERIC-FUNCTION"><code>edge-score</code></a>. If
you are thinking of customizing this, for example to make it choose
the minimum at odd depths, the you may want to consider specializing
REWARD or <a href="#MICMAC.UCT:UPDATE-UCT-STATISTICS%20GENERIC-FUNCTION" title="MICMAC.UCT:UPDATE-UCT-STATISTICS GENERIC-FUNCTION"><code>update-uct-statistics</code></a> instead.</p></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3AOUTCOME--3EREWARD-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.UCT:OUTCOME-%3EREWARD%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L127">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:OUTCOME-%3EREWARD%20GENERIC-FUNCTION" >outcome-&gt;reward</a></span></span> <span class="locative-args">node outcome</span></span></p>

<p>Compute the reward for a node in the tree from
<code>outcome</code> that is the result of a playout. This is called by the
default implementation of <a href="#MICMAC.UCT:UPDATE-UCT-STATISTICS%20GENERIC-FUNCTION" title="MICMAC.UCT:UPDATE-UCT-STATISTICS GENERIC-FUNCTION"><code>update-uct-statistics</code></a>. This is where one
typically negates depending on the parity of <a href="#MICMAC.UCT:DEPTH%20%28MGL-PAX:READER%20MICMAC.UCT:UCT-NODE%29" title="MICMAC.UCT:DEPTH (MGL-PAX:READER MICMAC.UCT:UCT-NODE)"><code>depth</code></a> in two player
games.</p></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3AUPDATE-UCT-STATISTICS-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.UCT:UPDATE-UCT-STATISTICS%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L136">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:UPDATE-UCT-STATISTICS%20GENERIC-FUNCTION" >update-uct-statistics</a></span></span> <span class="locative-args">root path outcome</span></span></p>

<p>Increment the number of visits and update the
average reward in nodes and edges of <code>path</code>. By default, edges simply
get their visit counter incremented while nodes also get an update
to <a href="#MICMAC.UCT:AVERAGE-REWARD%20%28MGL-PAX:ACCESSOR%20MICMAC.UCT:UCT-NODE%29" title="MICMAC.UCT:AVERAGE-REWARD (MGL-PAX:ACCESSOR MICMAC.UCT:UCT-NODE)"><code>average-reward</code></a> based on what <a href="#MICMAC.UCT:OUTCOME-%3EREWARD%20GENERIC-FUNCTION" title="MICMAC.UCT:OUTCOME-&gt;REWARD GENERIC-FUNCTION"><code>outcome-&gt;reward</code></a> returns.</p></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3AMAKE-UCT-NODE-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.UCT:MAKE-UCT-NODE%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L150">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:MAKE-UCT-NODE%20GENERIC-FUNCTION" >make-uct-node</a></span></span> <span class="locative-args">parent edge parent-state</span></span></p>

<p>Create a node representing the state that <code>edge</code>
leads to (from <code>parent</code>). Specialize this if you want to keep track of
the state, which is not done by default as it can be expensive,
especially in light of TAKE-ACTION mutating it. The default
implementation simply creates an instance of the class of <code>parent</code> so
that one can start from a subclass of <a href="#MICMAC.UCT:UCT-NODE%20CLASS" title="MICMAC.UCT:UCT-NODE CLASS"><code>uct-node</code></a> and be sure that that
class is going to be used for nodes below it.</p></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3ASTATE-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.UCT:STATE%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L162">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:STATE%20GENERIC-FUNCTION" >state</a></span></span> <span class="locative-args">node parent edge parent-state</span></span></p>

<p>Return the state that corresponds to <code>node</code>. This is
not a straightforward accessor unless <code>node</code> is customized to store
it. The rest of the parameters are provided so that one can
reconstruct the state by taking the action of <code>edge</code> in the
<code>parent-state</code> of <code>parent</code>. It's allowed to mutate <code>parent-state</code> and
return it. This function must be specialized.</p></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3ALIST-EDGES-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.UCT:LIST-EDGES%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L170">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:LIST-EDGES%20GENERIC-FUNCTION" >list-edges</a></span></span> <span class="locative-args">node state</span></span></p>

<p>Return a list of edges representing the possible
actions from <code>node</code> with <code>state</code>. This function must be customized.</p></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3APLAY-OUT-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.UCT:PLAY-OUT%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L174">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:PLAY-OUT%20GENERIC-FUNCTION" >play-out</a></span></span> <span class="locative-args">node state reverse-path</span></span></p>

<p>Play a random game from <code>node</code> with <code>state</code> and return
the outcome that's fed into <a href="#MICMAC.UCT:UPDATE-UCT-STATISTICS%20GENERIC-FUNCTION" title="MICMAC.UCT:UPDATE-UCT-STATISTICS GENERIC-FUNCTION"><code>update-uct-statistics</code></a>. The way the
random game is played is referred to as `default policy' and that's
what makes or breaks <a href="#MICMAC.UCT:UCT%20FUNCTION" title="MICMAC.UCT:UCT FUNCTION"><code>uct</code></a> search. This function must be
customized.</p></li>
</ul>

<p><a id="x-28MICMAC-2EUCT-3AUCT-20FUNCTION-29"></a>
<a id="MICMAC.UCT:UCT%20FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/uct.lisp#L181">[function]</a></span> <span class="reference-object"><a href="#MICMAC.UCT:UCT%20FUNCTION" >uct</a></span></span> <span class="locative-args">&amp;key root fresh-root-state exploration-bias max-n-playouts</span></span></p>

<p>Starting from the <code>root</code> node, search the tree expanding it one node
for each playout. Finally return the mutated <code>root</code>. <code>root</code> may be the
root node of any tree, need not be a single node with no edges.
<code>fresh-root-state</code> is a function that returns a fresh state
corresponding to <code>root</code>. This state will be destroyed unless special
care is taken in <a href="#MICMAC.UCT:STATE%20GENERIC-FUNCTION" title="MICMAC.UCT:STATE GENERIC-FUNCTION"><code>state</code></a>.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3A-40MICMAC-METROPOLIS-HASTINGS-20MGL-PAX-3ASECTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:@MICMAC-METROPOLIS-HASTINGS%20MGL-PAX:SECTION"></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#MICMAC.UCT:@MICMAC-UCT%20MGL-PAX:SECTION" title="UCT">&#8592;</a> <a href="#MICMAC:@MICMAC-MANUAL%20MGL-PAX:SECTION" title="Micmac Manual">&#8593;</a> <a href="#MICMAC.GAME-THEORY:@MICMAC-GAME-THEORY%20MGL-PAX:SECTION" title="Game Theory">&#8594;</a> <a href="#MICMAC.METROPOLIS-HASTINGS:@MICMAC-METROPOLIS-HASTINGS%20MGL-PAX:SECTION" title="Metropolis Hastings">&#8634;</a> <a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L3">&#955;</a></span></span></p>

<h2><a href="#MICMAC.METROPOLIS-HASTINGS:@MICMAC-METROPOLIS-HASTINGS%20MGL-PAX:SECTION">4 Metropolis Hastings</a></h2>

<h6>[in package MICMAC.METROPOLIS-HASTINGS with nicknames MICMAC.MH]</h6>

<p>Generic interface for the Metropolis-Hastings algorithm, also
Metropolis Coupled MCMC.</p>

<p>References:</p>

<ul>
<li><p>http://en.wikipedia.org/wiki/Metropolis–Hastings_algorithm</p></li>
<li><p>Markov Chain Monte Carlo and Gibbs Sampling
  Lecture Notes for EEB 581, version 26 April 2004 c B. Walsh 2004
  http://web.mit.edu/~wingated/www/introductions/mcmc-gibbs-intro.pdf</p></li>
<li><p>Geyer, C.J. (1991) Markov chain Monte Carlo maximum likelihood</p></li>
</ul>

<p>For now, the documentation is just a reference. See
<code>test/test-metropolis-hastings.lisp</code> for an example.</p>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3AMC-CHAIN-20CLASS-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:MC-CHAIN%20CLASS"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L42">[class]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:MC-CHAIN%20CLASS" >mc-chain</a></span></span></span></p>

<p>A simple markov chain for Metropolis Hastings. With
temperature it is suitable for <code>mc3</code>.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3ATEMPERATURE-20-28MGL-PAX-3AACCESSOR-20MICMAC-2EMETROPOLIS-HASTINGS-3AMC-CHAIN-29-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:TEMPERATURE%20%28MGL-PAX:ACCESSOR%20MICMAC.METROPOLIS-HASTINGS:MC-CHAIN%29"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L43">[accessor]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:TEMPERATURE%20%28MGL-PAX:ACCESSOR%20MICMAC.METROPOLIS-HASTINGS:MC-CHAIN%29" >temperature</a></span></span> <span class="locative-args">mc-chain</span> <span class="locative-args">(:temperature = 1.0d0)</span></span></p>

<p>The PROBABILITY-RATIO of samples is raised to the
power of 1 / <code>temperature</code> before calculating the acceptance
probability. This effectively flattens the peaks if <code>temperature</code> &gt;
1 which makes it easier for the chain to traverse deep valleys.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3ASTATE-20-28MGL-PAX-3AREADER-20MICMAC-2EMETROPOLIS-HASTINGS-3AMC-CHAIN-29-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:STATE%20%28MGL-PAX:READER%20MICMAC.METROPOLIS-HASTINGS:MC-CHAIN%29"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L49">[reader]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:STATE%20%28MGL-PAX:READER%20MICMAC.METROPOLIS-HASTINGS:MC-CHAIN%29" >state</a></span></span> <span class="locative-args">mc-chain</span> <span class="locative-args">(:state)</span></span></p>

<p>This is the current sample where the chain is.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3AJUMP-TO-SAMPLE-20FUNCTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:JUMP-TO-SAMPLE%20FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L67">[function]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:JUMP-TO-SAMPLE%20FUNCTION" >jump-to-sample</a></span></span> <span class="locative-args">chain jump &amp;key (result-sample (state chain))</span></span></p>

<p>From the current state of <code>chain</code> make <code>jump</code> (from the current
distribution of <code>chain</code>) and return the sample where we landed. Reuse
<code>result-sample</code> when possible. </p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3AJUMP-TO-SAMPLE-2A-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:JUMP-TO-SAMPLE*%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L73">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:JUMP-TO-SAMPLE*%20GENERIC-FUNCTION" >jump-to-sample*</a></span></span> <span class="locative-args">chain jump result-sample</span></span></p>

<p>This function is called by <a href="#MICMAC.METROPOLIS-HASTINGS:JUMP-TO-SAMPLE%20FUNCTION" title="MICMAC.METROPOLIS-HASTINGS:JUMP-TO-SAMPLE FUNCTION"><code>jump-to-sample</code></a>. It is
where <code>jump-to-sample</code> behaviour shall be customized.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3APREPARE-JUMP-DISTRIBUTION-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:PREPARE-JUMP-DISTRIBUTION%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L77">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:PREPARE-JUMP-DISTRIBUTION%20GENERIC-FUNCTION" >prepare-jump-distribution</a></span></span> <span class="locative-args">chain</span></span></p>

<p>Prepare for sampling from the F(X) = Q(SAMPLE-&gt;X)
distribution. Called by <a href="#MICMAC.METROPOLIS-HASTINGS:RANDOM-JUMP%20GENERIC-FUNCTION" title="MICMAC.METROPOLIS-HASTINGS:RANDOM-JUMP GENERIC-FUNCTION"><code>random-jump</code></a>. The around method ensures that
nothing is done unless there was a state change.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3ARANDOM-JUMP-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:RANDOM-JUMP%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L86">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:RANDOM-JUMP%20GENERIC-FUNCTION" >random-jump</a></span></span> <span class="locative-args">chain</span></span></p>

<p>Sample a jump from the current distribution of
jumps that was computed by <a href="#MICMAC.METROPOLIS-HASTINGS:PREPARE-JUMP-DISTRIBUTION%20GENERIC-FUNCTION" title="MICMAC.METROPOLIS-HASTINGS:PREPARE-JUMP-DISTRIBUTION GENERIC-FUNCTION"><code>prepare-jump-distribution</code></a>.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3ALOG-PROBABILITY-RATIO-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:LOG-PROBABILITY-RATIO%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L92">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:LOG-PROBABILITY-RATIO%20GENERIC-FUNCTION" >log-probability-ratio</a></span></span> <span class="locative-args">chain sample1 sample2</span></span></p>

<p>Return P(<code>sample1</code>)/P(<code>sample2</code>). It's in the log
domain to avoid overflows and the ratio part is because that it may
allow computational shortcuts as opposed to calculating unnormalized
probabilities separately.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3ALOG-PROBABILITY-RATIO-TO-JUMP-TARGET-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:LOG-PROBABILITY-RATIO-TO-JUMP-TARGET%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L98">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:LOG-PROBABILITY-RATIO-TO-JUMP-TARGET%20GENERIC-FUNCTION" >log-probability-ratio-to-jump-target</a></span></span> <span class="locative-args">chain jump target</span></span></p>

<p>Return P(<code>target</code>)/P(<a href="#MICMAC.METROPOLIS-HASTINGS:STATE%20%28MGL-PAX:READER%20MICMAC.METROPOLIS-HASTINGS:MC-CHAIN%29" title="MICMAC.METROPOLIS-HASTINGS:STATE (MGL-PAX:READER MICMAC.METROPOLIS-HASTINGS:MC-CHAIN)"><code>state</code></a>) where <code>jump</code> is from the
current state of <code>chain</code> to <code>target</code> sample. This can be specialized for
speed. The default implementation just falls back on
<a href="#MICMAC.METROPOLIS-HASTINGS:LOG-PROBABILITY-RATIO%20GENERIC-FUNCTION" title="MICMAC.METROPOLIS-HASTINGS:LOG-PROBABILITY-RATIO GENERIC-FUNCTION"><code>log-probability-ratio</code></a>.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3ALOG-JUMP-PROBABILITY-RATIO-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:LOG-JUMP-PROBABILITY-RATIO%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L106">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:LOG-JUMP-PROBABILITY-RATIO%20GENERIC-FUNCTION" >log-jump-probability-ratio</a></span></span> <span class="locative-args">chain jump target</span></span></p>

<p>Return Q(TARGET-&gt;STATE) / Q(STATE-&gt;TARGET) where Q
is the jump distribution and <code>jump</code> is from the current <a href="#MICMAC.METROPOLIS-HASTINGS:STATE%20%28MGL-PAX:READER%20MICMAC.METROPOLIS-HASTINGS:MC-CHAIN%29" title="MICMAC.METROPOLIS-HASTINGS:STATE (MGL-PAX:READER MICMAC.METROPOLIS-HASTINGS:MC-CHAIN)"><code>state</code></a> of <code>chain</code>
to <code>target</code> sample.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3AACCEPTANCE-PROBABILITY-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:ACCEPTANCE-PROBABILITY%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L117">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:ACCEPTANCE-PROBABILITY%20GENERIC-FUNCTION" >acceptance-probability</a></span></span> <span class="locative-args">chain jump candidate</span></span></p>

<p>Calculate the acceptance probability of <code>candidate</code>
to which <code>jump</code> leads from the current <a href="#MICMAC.METROPOLIS-HASTINGS:STATE%20%28MGL-PAX:READER%20MICMAC.METROPOLIS-HASTINGS:MC-CHAIN%29" title="MICMAC.METROPOLIS-HASTINGS:STATE (MGL-PAX:READER MICMAC.METROPOLIS-HASTINGS:MC-CHAIN)"><code>state</code></a> of <code>chain</code>.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3AACCEPT-JUMP-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:ACCEPT-JUMP%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L126">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:ACCEPT-JUMP%20GENERIC-FUNCTION" >accept-jump</a></span></span> <span class="locative-args">chain jump candidate</span></span></p>

<p>Called when <code>chain</code> accepts <code>jump</code> to <code>candidate</code>.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3AREJECT-JUMP-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:REJECT-JUMP%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L136">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:REJECT-JUMP%20GENERIC-FUNCTION" >reject-jump</a></span></span> <span class="locative-args">chain jump candidate</span></span></p>

<p>Called when <code>chain</code> rejects <code>jump</code> to <code>candidate</code>. It
does nothing by default, it's just a convenience for debugging.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3AMAYBE-JUMP-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:MAYBE-JUMP%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L141">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:MAYBE-JUMP%20GENERIC-FUNCTION" >maybe-jump</a></span></span> <span class="locative-args">chain jump candidate acceptance-probability</span></span></p>

<p>Randomly accept or reject <code>jump</code> to <code>candidate</code> from
the current state of <code>chain</code> with <code>acceptance-probability</code>.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3AJUMP-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:JUMP%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L152">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:JUMP%20GENERIC-FUNCTION" >jump</a></span></span> <span class="locative-args">chain</span></span></p>

<p>Take a step on the markov chain. Return a boolean
indicating whether the proposed jump was accepted.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3AMC3-CHAIN-20CLASS-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:MC3-CHAIN%20CLASS"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L167">[class]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:MC3-CHAIN%20CLASS" >mc3-chain</a></span></span> <span class="locative-args"><a href="#MICMAC.METROPOLIS-HASTINGS:MC-CHAIN%20CLASS" title="MICMAC.METROPOLIS-HASTINGS:MC-CHAIN CLASS">mc-chain</a></span></span></p>

<p>High probability island separated by low valley
make the chain poorly mixing. <code>mc3-chain</code> has a number of <code>hot-chains</code>
that have state probabilities similar to that of the main chain but
less jagged. Often it suffices to set the temperatures of the
<code>hot-chains</code> higher use the very same base probability
distribution.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3AACCEPT-SWAP-CHAIN-STATES-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:ACCEPT-SWAP-CHAIN-STATES%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L177">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:ACCEPT-SWAP-CHAIN-STATES%20GENERIC-FUNCTION" >accept-swap-chain-states</a></span></span> <span class="locative-args">mc3 chain1 chain2</span></span></p>

<p>Swap the states of <code>chain1</code> and <code>chain2</code> of <code>mc3</code>.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3AREJECT-SWAP-CHAIN-STATES-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:REJECT-SWAP-CHAIN-STATES%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L182">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:REJECT-SWAP-CHAIN-STATES%20GENERIC-FUNCTION" >reject-swap-chain-states</a></span></span> <span class="locative-args">mc3 chain1 chain2</span></span></p>

<p>Called when the swap of states of <code>chain1</code> and <code>chain2</code>
is rejected. It does nothing by default, it's just a convenience for
debugging.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3AMAYBE-SWAP-CHAIN-STATES-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:MAYBE-SWAP-CHAIN-STATES%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L193">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:MAYBE-SWAP-CHAIN-STATES%20GENERIC-FUNCTION" >maybe-swap-chain-states</a></span></span> <span class="locative-args">mc3 chain1 chain2 acceptance-probability</span></span></p>

<p>Swap of states of <code>chain1</code> and <code>chain2</code> of <code>mc3</code> with
<code>acceptance-probability</code>.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3AJUMP-BETWEEN-CHAINS-20GENERIC-FUNCTION-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:JUMP-BETWEEN-CHAINS%20GENERIC-FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L204">[generic-function]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:JUMP-BETWEEN-CHAINS%20GENERIC-FUNCTION" >jump-between-chains</a></span></span> <span class="locative-args">mc3</span></span></p>

<p>Choose two chains randomly and swap their states
with <code>mc3</code> acceptance probability.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3AENUMERATING-CHAIN-20CLASS-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:ENUMERATING-CHAIN%20CLASS"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L257">[class]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:ENUMERATING-CHAIN%20CLASS" >enumerating-chain</a></span></span> <span class="locative-args"><a href="#MICMAC.METROPOLIS-HASTINGS:MC-CHAIN%20CLASS" title="MICMAC.METROPOLIS-HASTINGS:MC-CHAIN CLASS">mc-chain</a></span></span></p>

<p>A simple abstract chain subclass that explicitly
enumerates the probabilities of the distribution.</p></li>
</ul>

<p><a id="x-28MICMAC-2EMETROPOLIS-HASTINGS-3ATRACING-CHAIN-20CLASS-29"></a>
<a id="MICMAC.METROPOLIS-HASTINGS:TRACING-CHAIN%20CLASS"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/metropolis-hastings.lisp#L273">[class]</a></span> <span class="reference-object"><a href="#MICMAC.METROPOLIS-HASTINGS:TRACING-CHAIN%20CLASS" >tracing-chain</a></span></span></span></p>

<p>Mix this in with your chain to have it print trace
of acceptances/rejections.</p></li>
</ul>

<p><a id="x-28MICMAC-2EGAME-THEORY-3A-40MICMAC-GAME-THEORY-20MGL-PAX-3ASECTION-29"></a>
<a id="MICMAC.GAME-THEORY:@MICMAC-GAME-THEORY%20MGL-PAX:SECTION"></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#MICMAC.METROPOLIS-HASTINGS:@MICMAC-METROPOLIS-HASTINGS%20MGL-PAX:SECTION" title="Metropolis Hastings">&#8592;</a> <a href="#MICMAC:@MICMAC-MANUAL%20MGL-PAX:SECTION" title="Micmac Manual">&#8593;</a> <a href="#MICMAC.GAME-THEORY:@MICMAC-GAME-THEORY%20MGL-PAX:SECTION" title="Game Theory">&#8634;</a> <a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/game-theory.lisp#L3">&#955;</a></span></span></p>

<h2><a href="#MICMAC.GAME-THEORY:@MICMAC-GAME-THEORY%20MGL-PAX:SECTION">5 Game Theory</a></h2>

<h6>[in package MICMAC.GAME-THEORY]</h6>

<p><a id="x-28MICMAC-2EGAME-THEORY-3AFIND-NASH-EQUILIBRIUM-20FUNCTION-29"></a>
<a id="MICMAC.GAME-THEORY:FIND-NASH-EQUILIBRIUM%20FUNCTION"></a></p>

<ul>
<li><p><span class=reference-bullet><span class=reference><span class="locative-type"><a href="https://github.com/melisgl/micmac/blob/643e3545450d5dc380401e3fb11798b7bd571839/src/game-theory.lisp#L32">[function]</a></span> <span class="reference-object"><a href="#MICMAC.GAME-THEORY:FIND-NASH-EQUILIBRIUM%20FUNCTION" >find-nash-equilibrium</a></span></span> <span class="locative-args">payoff &amp;key (n-iterations 100)</span></span></p>

<p>Find a Nash equilibrium of a zero-sum game represented by <code>payoff</code>
matrix (a 2d matrix or a nested list). <code>payoff</code> is from the point of
view of the row player: the player who choses column wants to
minimize, the row player wants to maximize. The first value returned
is a vector of unnormalized probabilities assigned to each action of
the row player, the second value is the same for the column player
and the third is the expected payoff of the row player in the nash
equilibrium represented by the oddment vectors.</p></li>
</ul>
  </div>
</div>
<script>$('#page-toc').toc({'selectors': 'h1,h2,h3,h4'});</script>
</body>
</html>
